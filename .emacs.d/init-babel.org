#+TITLE: Jörgs Emacs init
* Emacs Configuration
** Lisp functions
*** Initialization

We want to set each frame to reasonable color defaults by defining an
appropriate hook. We also call it for the current frame.

#+BEGIN_SRC emacs-lisp
(add-hook 'after-make-frame-functions
	  (lambda (frame)
	    (set-frame-parameter nil 'alpha '(95 . 95))
	    (with-selected-frame frame
	      (set-background-color "Black")
	      (set-foreground-color "Green")
	      )))
(run-hook-with-args 'after-make-frame-functions (selected-frame))
#+END_SRC

*** Handling of other window

I'm adding some useful functions for handling the other window after calling
or navigating within help texts for example.

#+BEGIN_SRC emacs-lisp
(defun go-back-other-window ()
  "Go back to previous help topic in other window."
  (interactive)
  (with-current-buffer (window-buffer (next-window))
    (help-go-back)))

(defun quit-restore-other-window ()
  "Quit other window and deal with its buffer, possibly restoring
      the buffer previously displayed in other window."
  (interactive)
  (quit-restore-window (next-window)))

(defun shrink-other-window-if-larger-than-buffer ()
  "Shrink height of other window if its buffer doesn't need so many lines."
  (interactive)
  (shrink-window-if-larger-than-buffer (next-window)))

(defun fit-other-window ()
  "balance or shrink other window giving it an appropriate space."
  (interactive)
  (balance-windows)
  (shrink-window-if-larger-than-buffer (next-window)))
#+END_SRC

*** Convenient error stepping

Often I want to quickly navigate through a list of error messages or
occurencies, jumping to the places the errors are indicating. There are
different ways to archieve this. First of all, with ~C-x C-f~ you can activate
~error-follow-minor-mode~, allowing to move the mark through the error buffer,
letting the referenced source buffers follow you. But if you want to have the
source buffer active, you would need to jump to the error buffer for each next
step. As a remedy, the following functions are introduced. While they follow
the previous scheme adding remote control functions for the other window, they
also show a cool feature of setting a temporary keymap in place, allowing
further navigation steps by using shortcuts. This way, the long key sequence
of addressing the other window (~C-x 4~) and starting the goto sequence
(~M-g~) needs to be casted only as an initiation. Afterwards, it gets really
easy. This is quite convenient in the most different applications.

#+BEGIN_SRC emacs-lisp
(require 'cl)

(defun error-step ()
  (macrolet ((step-msg ()
		       '(message "Use n,p,< to navigate further")))
    (step-msg)
    (set-transient-map
     (let ((map (make-sparse-keymap)))
       (dolist (modk '(() (meta)))
	 (define-key map (vector (append modk '(?n)))
	   (lambda () (interactive) (next-error) (step-msg)))
	 (define-key map (vector (append modk '(?<)))
	   (lambda () (interactive) (first-error) (step-msg)))
	 (define-key map (vector (append modk '(?p)))
	   (lambda () (interactive) (previous-error) (step-msg))))
       map) 't)))

(defun next-error-other-window (&optional arg)
  "Visit next error message displayed in other window's buffer."
  (interactive "P")
  (with-current-buffer (window-buffer (next-window))
    (next-error arg)
    (error-step)))

(defun previous-error-other-window (&optional arg)
  "Visit previous error message displayed in other window's buffer."
  (interactive "P")
  (with-current-buffer (window-buffer (next-window))
    (previous-error arg)
    (error-step)))
#+END_SRC

*** Convenient Navigation Mode

This is an experimental feature in the spirit of previous means of other
window handling, allowing for activation of a temporary navigation mode. Using
this, you can conveniently navigate, scroll, set marks and jump to previous
mark positions. Features include navigating up and down of the point,
scrolling up and down, jumping to begin and end of buffer, pagewise up and
down. Most of these can be combined with a numeric argument. The mode is
cancelled by using any other key.

#+BEGIN_SRC emacs-lisp
(defun navigate-buffer (&optional window)
  "Enter a temporary buffer navigation mode. WINDOW specifies an optional window pointer,
allowing to specify a remote window to be controlled."
  (lexical-let ((arg-acc 0) (arg-neg nil) (consumed nil)
		(window (or window (selected-window))))
    (labels ((set-consumed () (setq consumed 't))
	     (acc-reset ()
			(if consumed
			    (setq arg-acc 0 arg-neg nil consumed nil)))
	     (get-arg-acc (&optional default)
			  (let ((res (if (> arg-acc 0)
					 (* arg-acc (if arg-neg -1 1))
				       default)))
			    res))
	     (acc-status () (message "navigate ([-,0-9] n,p,N,P,v,V,<,>,[,],l, ) %c %d"
				     (if arg-neg arg-neg '? ) arg-acc))
	     (arg-negate ()
			 (setq arg-neg (if arg-neg nil '?-))
			 (acc-status))
	     (arg-accumulate (num)
			     (setq arg-acc (+ (* arg-acc 10) num))
			     (acc-status)))
      (macrolet ((with-window (&rest body)
			      `(lambda () (interactive)
				 (set-consumed)
				 (with-selected-window window
				   ,@body
				   (acc-status)))))
	(acc-status)
	(set-transient-map
	 (let ((map (make-sparse-keymap)))
	   (define-key map [?-] (lambda () (interactive) (acc-reset) (arg-negate)))
	   (dolist (num '(?0 ?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9))
	     (define-key map (vector num)
	       (lambda ()
		 (interactive)
		 (acc-reset)
		 (let* ((ev last-command-event)
			(base (event-basic-type ev)))
		   (arg-accumulate (- base 48))))))
	   (define-key map " " (with-window
				(if (eq arg-acc 0)
				    (progn (set-mark-command nil)(deactivate-mark))
				  (set-mark-command (get-arg-acc)))))
	   (define-key map "n" (with-window (next-line (get-arg-acc 1))))
	   (define-key map "p" (with-window (previous-line (get-arg-acc 1))))
	   (define-key map "/" (with-window (isearch-forward))) ;not documented
	   (define-key map "l" (with-window (recenter-top-bottom (get-arg-acc))))
	   (define-key map "r" (with-window (move-to-window-line-top-bottom (get-arg-acc))))
	   (define-key map "<" (with-window (beginning-of-buffer (get-arg-acc))))
	   (define-key map ">" (with-window (end-of-buffer (get-arg-acc))))
	   (define-key map "]" (with-window (forward-paragraph (get-arg-acc))))
	   (define-key map "[" (with-window (backward-paragraph (get-arg-acc))))
	   (define-key map "N" (with-window (scroll-up-line (get-arg-acc 1))))
	   (define-key map "P" (with-window (scroll-down-line (get-arg-acc 1))))
	   (define-key map "v" (with-window (scroll-up-command (get-arg-acc))))
	   (define-key map "V" (with-window (scroll-down-command (get-arg-acc))))
	 map) 't)))))

(defun navigate-window (&optional arg)
  "Enter a temporary buffer navigation mode, allowing some window to be
controlled remotely. Default is the selected window. Optional argument
selects the nth window. This allows moving around some window without
de-selecting the current window, enabling a very convenient means of
temporarily moving around. 

Keys are:
  -, 0-9: set an argument to following commands, which stays in effect until
          reset (e.g. by pressing 0)
  space: set a mark; with arg jump to mark
  n, p: move point to next/previous line
  l: recenter buffer to point
  r: move point to window center
  <, >: move point to beginning/end of buffer
  [, ]: move point forward/backward in paragraphs
  N, P: scroll up/down
  v, V: pagewise scroll up/down"
  (interactive "p")
  (navigate-buffer
   (let ((wnd (selected-window))
	 (cnt (if arg arg 0)))
     (while (> cnt 1)
       (setq wnd (next-window wnd) cnt (- cnt 1)))
     wnd)))

(defun navigate-other-window ()
  "Enter a temporary remote buffer navigation mode for next or other window.
For details, see `navigate-window'."
  (interactive)
  (navigate-buffer (next-window)))
#+END_SRC

*** Windows run commands

For Windows, we define a few shortcuts running command shells, using these as
a kind of ~ansi-term~ replacement.

#+BEGIN_SRC emacs-lisp
(defun run-cmdexe ()
  (interactive)
  (let ((shell-file-name "cmd.exe"))
    (shell "*cmd.exe*")))

(defun run-sdk ()
  (interactive)
  (let ((shell-file-name "c:\\sdk\\win32\\1.1\\scripts\\sdk-shell-vs90.bat"))
    (shell "*sdk*")))

(defun run-bash ()
  (interactive)
  (let ((shell-file-name "c:\\Program Files\\Git\\bin\\bash.exe"))
    (shell "*bash*")))
#+END_SRC

*** Frame and window size

Interactively resize windows.

#+BEGIN_SRC emacs-lisp
(defun resize-window ()
  "Resize current window interactively using continuous key presses.
Keys supported:

 - shrink window vertically
 + enlarge window vertically
 [ shrink window horizontally
 ] enlarge window horizontally
 0 balance all frames window sizes"
  (interactive)
  (macrolet ((msg ()
		  '(message "resize window (-,+,[,],0)"))
	     (lmb (fnc)
		  `(lambda () (interactive)
		     (msg)
		     ,fnc)))
    (msg)
    (set-transient-map
     (let ((tmap (make-sparse-keymap)))
       (define-key tmap "0" (lmb (balance-windows)))
       (define-key tmap "-" (lmb (shrink-window 1)))
       (define-key tmap "+" (lmb (enlarge-window 1)))
       (define-key tmap "=" (lmb (enlarge-window 1))) ; easy access on us keyboard
       (define-key tmap "^" (lmb (enlarge-window 1))) ; reuse entry key
       (define-key tmap "&" (lmb (enlarge-window 1))) ; german keyboard
       (define-key tmap "{" (lmb (shrink-window-horizontally 1)))
       (define-key tmap "Ü" (lmb (shrink-window-horizontally 1))) ; german keyboard, here "U
       (define-key tmap "}" (lmb (enlarge-window-horizontally 1)))
       (define-key tmap "*" (lmb (enlarge-window-horizontally 1))) ; german keyboard
       tmap) 't)))
#+END_SRC

This used to be a frame maximize function for Mac, which is not longer neeeded
here. Nevertheless, this may work as foundation for functions realizing some
visually attractive full screen mode and reverting to the previous frame size.
"Visually attractive" would then be something like "leave a small configurable
space outside the frame and use the rest of screen".

#+BEGIN_SRC emacs-lisp
(defun switch-frame ()
  "Set frame to reasonable position and size based on some heuristics.
  Alternatively, toggles size to maximized."
  (interactive)
  (let ((maximized (frame-parameter nil 'fullscreen)))
    (cond
     ((eq maximized 'maximized)
      (let ((lines (frame-parameter nil 'height)))
	(set-frame-parameter nil 'fullscreen nil)
	(set-frame-width nil (- split-width-threshold 1))
	(set-frame-height nil (- lines 1))
	(set-frame-position nil 0 8)))
     ('t
      (set-frame-parameter nil 'fullscreen 'maximized)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun toggle-maximize-frame ()
  "Toggle fullscreen and switch off menu bar and scroll bar."
  (interactive)
  (labels ((set-scroll-bar (where) (customize-set-variable 'scroll-bar-mode where)))
    (let ((fullscreen (frame-parameter nil 'fullscreen)))
      (cond
       ((memq fullscreen '(fullscreen fullboth))
	(set-scroll-bar (frame-parameter nil 'scrollbar))
	(set-frame-parameter nil 'scrollbar nil)
	(toggle-menu-bar-mode-from-frame 1))
       (t
	(set-frame-parameter nil 'scrollbar scroll-bar-mode)
	(menu-bar-no-scroll-bar)
	(toggle-menu-bar-mode-from-frame 0)))))
  (toggle-frame-fullscreen))
#+END_SRC

** Global key bindings
*** Generic

Some convenience keys for handling buffers, files and window sizes. Use
caution and check to not shadow future functionality here.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x\C-b" 'bs-show)	;; this used to be electric-buffer-list
(global-set-key "\C-c\C-v" 'find-file-at-point)
(global-set-key "\C-x\C-f" 'find-file)
#+END_SRC

*** Scrolling

Convenience keys for buffer scrolling. Enables up/down also with /Meta/
modifier. Together with /Shift/ this enables scrolling. This way you can very
conveniently move the pointer and scroll by just adding/releasing the /Shift/
modifier.

#+BEGIN_SRC emacs-lisp
(global-set-key "\M-p" 'previous-line)
(global-set-key "\M-n" 'next-line)
(global-set-key "\M-P" 'scroll-down-line)
(global-set-key "\M-N" 'scroll-up-line)
(global-set-key [end] 'move-end-of-line)
(global-set-key [home] 'move-beginning-of-line)
#+END_SRC

*** Ace zapping

Ace enables some more vi-style jumping and zapping (see ~M-z~ for the basic
~zap-to-char~ function).

#+BEGIN_SRC emacs-lisp
(global-set-key "\M-J" 'ace-jump-char-mode)
;;;(global-set-key "\C-x\C-j" 'ace-jump-mode-pop-mark) ;; this is dired-jump
(global-set-key "\C-x\C-z" 'zzz-up-to-char)
#+END_SRC

*** Mouse handling

Mouse keys: remember basic mouse button handling in emacs: left - set pointer,
double left - select word, triple left - select line, drag - select, drag
after double - select words, right - define region and save to kill ring,
right after double click - define region up to next word, double right - kill
to kill ring, middle - yank to click position.

As on Mac middle button may be otherwise occupied, use mouse-3
together with /Meta/ as replacement.

~mouse-wheel-mode~ also enables mouse wheel scrolling. With /Meta/,
enables scroll turbo; with /shift/, scale text.

#+BEGIN_SRC emacs-lisp
;; mac trackpad: select: mouse-1, copy/cut: mouse-3, yank: M-mouse-3
;; undo: C-M-mouse-3
;; as a convenience, on mode line M-mouse-1 is also mouse-2
;; (define-key key-translation-map (kbd "<M-mouse-3>") (kbd "<mouse-2>"))
;; (global-set-key [C-M-mouse-3] 'undo)
(define-key key-translation-map (kbd "<mode-line> <M-mouse-3>") (kbd "<mode-line> <mouse-2>"))
(define-key key-translation-map (kbd "<mode-line> <M-mouse-1>") (kbd "<mode-line> <mouse-2>"))
(global-set-key [M-mouse-3] 'mouse-yank-at-click)
;; mac mouse: select: mouse-1, copy/cut: mouse-3, yank: M-mouse-2,
;; undo: M-mouse-3
(global-set-key [M-mouse-2] 'mouse-yank-at-click)
(global-set-key [M-mouse-3] 'undo)
#+END_SRC

*** Keyboard handling

On a german keyboard, we want some of the more obscure mappings to be within
easier reach. This is done here for combinations otherwise unmapped.

#+BEGIN_SRC emacs-lisp
(defun activate-german-keymap ()
  "activate some generic mappings to be reachable in usual places on german keyboard."
  (global-set-key "\242" 'mark-word) ; M-@, here M-"
  (global-set-key "\246" 'delete-indentation) ; M-^, here M-&
  (global-set-key "\C-x&" 'enlarge-window) ; C-x ^, here C-x &
  (global-set-key "\C-x*" 'enlarge-window-horizontally) ; C-x }
  (global-set-key "\C-xÜ" 'shrink-window-horizontally)) ; C-x {
#+END_SRC

*** Window handling

We overrule ~C-x ^~ to use our window resizing method.

#+BEGIN_SRC emacs-lisp
(global-set-key [remap enlarge-window] 'resize-window)
#+END_SRC

And upgrade fullscreen experience. Use ~Meta-f10~ to toggle between maximized
and a size comprised of almost full height and a width just below
~split-width-threshold~; ~Meta-f11~ to toggle fullscreen including no window
decorations.

#+BEGIN_SRC emacs-lisp
(global-set-key [remap toggle-frame-fullscreen] 'toggle-maximize-frame)
(global-set-key [remap toggle-frame-maximized] 'switch-frame)
(global-set-key (kbd "<M-f11>") 'toggle-maximize-frame)
#+END_SRC

*** Remote controlling other window

As I got quite used to remote control the other window using ~C-x 4~ keys, 
I'm adding a few ones which I missed so far.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x4q" 'quit-restore-other-window)
(global-set-key "\C-x4l" 'go-back-other-window)
(global-set-key "\C-x4-" 'shrink-other-window-if-larger-than-buffer)
(global-set-key "\C-X4+" 'fit-other-window)
#+END_SRC

Note the window size changing keys, ~C-x ^~ to enlarge (also negative) and
~C-x -~ to shrink if buffer is smaller than window are a little bit asymetric.
While the enlargement key can be used to enlarge and shrink the current
window, the shrink key works only in one direction. So here we define an
adjacent key for the other window. For rescue, there is always ~C-x +~ to
balance windows.

We also want to jump to beginning/end in other window by ~C-M-<~ and ~C-M->~
(cf. ~C-M-v~ and ~C-M-V~ to scroll pagewise in other window).

#+BEGIN_SRC emacs-lisp
(global-set-key [201326652] (quote beginning-of-buffer-other-window))
(global-set-key [201326654] (quote end-of-buffer-other-window))
#+END_SRC

How to get these codes? Call ~M-x global-set-key RET C-M-< beg~.. to manually
define such a key, then call ~C-x ESC ESC~ and copy the resulting parametrized
command from minibuffer.
Alternatively, call ~M-: (read-key-sequence "> ")~.

Now come the key bindings for convenient error navigation, as promised above.

#+BEGIN_SRC emacs-lisp
(define-prefix-command 'other-goto-map)
(global-set-key "\C-x4\M-g" 'other-goto-map)
(define-key other-goto-map "\M-n" 'next-error-other-window)
(define-key other-goto-map "\M-p" 'previous-error-other-window)
#+END_SRC

Here we bind the temporary navigation mode to some useful keys for current and
other window.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x\C-v" 'navigate-window)
(global-set-key "\C-x4v" 'navigate-other-window)
#+END_SRC

** Misc

#+BEGIN_SRC emacs-lisp
;; (setenv "PATH" (concat "/opt/local/bin:/opt/local/sbin:" (getenv "PATH")))

;; (load-file "~/.emacs.d/keyboard-pc.el")


(setq w32-apps-modifier 'meta)
(setenv "PYTHONUNBUFFERED" "x")  ;; needed for windows? running python in comint frame
(setenv "SSH_ASKPASS" "git-gui--askpass")

(setq org-element-use-cache nil)  ;; temporarily disable org element cache
(load-library "realgud")
(load-library "evil")
(global-undo-tree-mode)
(require 'wdired)
(require 'helm-config)
(require 'ox-rst)
(global-set-key [remap dabbrev-expand] 'hippie-expand)
(setq erc-autojoin-channels-alist '(("freenode.net" "#latex-de" "##latinitas" "#NetBSD" "##bash-de" "#git" "#vim" "#emacs" "#erc" "#oberon" "#macosx")))

(global-magit-file-mode t)
(load "dired-x.el") ;; also enable C-x C-j

;; smartparens
(require 'smartparens-config)
(add-hook 'emacs-lisp-mode-hook #'smartparens-mode)

;; python
(elpy-enable)
;; Enable Flycheck
(when (require 'flycheck nil t)
  (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
  (add-hook 'elpy-mode-hook 'flycheck-mode))
;; Enable autopep8
(require 'py-autopep8)
;;(add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
;;(global-linum-mode)    ;; show line numbers
(global-hl-line-mode) ;; highlight current line of point

(define-key elpy-mode-map [remap previous-error] 'flycheck-previous-error)
(define-key elpy-mode-map [remap next-error] 'flycheck-next-error)

;; C-c C-z starts python interpreter in current project
;; for this, set python-shell-interpreter to path of buildout powerscript exe
;; and python-shell-interpreter-args to ""
#+END_SRC

** Mode-specific customizations
*** Evil mode

**** Evil defines

Here we implement some kind of .vimrc initialization.
This is also an example of defining an evil leader key and some adjacent keymaps.

#+BEGIN_SRC emacs-lisp
(defun evil-rc ()
  "evil local init/customization"
  (define-prefix-command 'leader-map)

  (define-key evil-normal-state-map " " leader-map)

  (define-key leader-map "b" 'list-buffers)
  (define-key leader-map "#" 'bs-show)
  (define-key leader-map "l" 'global-linum-mode)

  (define-prefix-command 'evil-other-window-map)
  (define-key leader-map "4" evil-other-window-map)
  (define-key evil-other-window-map "-" 'shrink-other-window-if-larger-than-buffer)
  (define-key evil-other-window-map "+" 'fit-other-window)
  (define-key evil-other-window-map "q" 'quit-restore-other-window)
  (define-key evil-other-window-map "l" 'go-back-other-window))
#+END_SRC

**** Evil Emacs config

When using evil-mode, set ~evil-exit-emacs-state~ to ~C-M-z~, as I'm used to
~suspend-frame~. Additionally, always enter evil mode in emacs state (see custom). This
way, without getting in the way it is always only a key press away.

#+BEGIN_SRC emacs-lisp
(define-key evil-emacs-state-map "\C-z" nil)
(define-key evil-emacs-state-map "\C-\M-z" 'evil-exit-emacs-state)
(define-key evil-normal-state-map "\C-\M-z" 'evil-emacs-state)
#+END_SRC

Now, after Initializing evil, we may probably also activate it in all buffers.

#+BEGIN_SRC emacs-lisp
(evil-rc)
(evil-mode)
#+END_SRC

*** C++ mode customizations, in use for aeons now

#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
          (function
           (lambda ()
             (c-toggle-auto-hungry-state 1)
             (c-set-style "Stroustrup")
	     (setq c-basic-offset 2)
             (setq c-hanging-braces-alist '((brace-list-open)
                                            (brace-list-close after)
                                            (defun-open after)
                                            (class-open after)
                                            (inline-open after)
                                            (substatement-open after))))))
#+END_SRC

*** Auto-fill-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'fundamental-mode-hook
         (lambda () (auto-fill-mode 1)))
(add-hook 'text-mode-hook
         (lambda () (auto-fill-mode 1)))
(add-hook 'org-mode-hook
         (lambda () (auto-fill-mode 1)))
#+END_SRC

*** python mode

The untabify-function defined here is currently disabled.

#+BEGIN_SRC emacs-lisp
(defun python-mode-untabify ()
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "[ \t]+$" nil t)
        (delete-region (match-beginning 0) (match-end 0)))
      (goto-char (point-min))
      (if (search-forward "\t" nil t)
          (untabify (1- (point)) (point-max))))
    nil)

;;(add-hook 'python-mode-hook
;;            '(lambda ()
;;               (make-local-variable 'write-contents-hooks)
;;               (add-hook 'write-contents-hooks 'python-mode-untabify)))
#+END_SRC

*** React programming

Combine javascript and web-mode, supporting ~jsx~ templates within. This is
probably outdated and should be re-evaluated. Is there already a real
react-mode? Otherwise, combine it with more up-to-date html-mode?

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.jsx\\'" . web-mode))
(add-hook 'web-mode-hook 'js2-minor-mode)
#+END_SRC

*** XML-mode 

**** hiding of subtrees

Here we use ~hs-mode~, enabling tag view toggling and tag level hiding. Also
~S-mouse-2~ can be used to toggle tag views.

#+BEGIN_SRC emacs-lisp
(setq sgml-quick-keys t)
(require 'hideshow)
(require 'sgml-mode)
(require 'nxml-mode)

(add-to-list 'hs-special-modes-alist
             '(nxml-mode
               "<!--\\|<[^/>]*[^/]>"
               "-->\\|</[^/>]*[^/]>"

               "<!--"
               sgml-skip-tag-forward
               nil))

(add-hook 'nxml-mode-hook 'hs-minor-mode)

(define-key nxml-mode-map (kbd "C-c C-h") 'hs-toggle-hiding)
(define-key nxml-mode-map (kbd "C-c C-l") 'hs-hide-level)
#+END_SRC

**** tagedit-mode

tbd

*** markdown mode

#+BEGIN_SRC emacs-lisp
(autoload 'markdown-mode "markdown-mode"
  "Major mode for editing Markdown files" t)
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
(setq markdown-command "/Users/jko/Programming/node/node_modules/.bin/md2html")
#+END_SRC

** Disabled commands

#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
(put 'narrow-to-page 'disabled nil)
#+END_SRC

** Todo

 - complete keyboard switching
 - complete mouse/trackpad handling/switching
 - cleanup misc, move to mode specific sections
