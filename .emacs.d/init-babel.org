# -*- org-html-postamble-format:(("en" "<p class="author">Author: %a
# (Reddit: <a href="https://www.reddit.com/user/e17i">u/e17i</a>)</p> <p>Made on
# emacs org-mode</p>"));
# org-html-postamble: t -*-
#
# #+HTML_HEAD: <link rel="stylesheet" type="text/css" href="chrome/rethink.css" />
#+HTML_HEAD_EXTRA: <img src="image1.jpg"/><div style="padding:2vh"><a style="font-weight:900; text-decoration:none" href="/">Home</a></div>
#+OPTIONS: toc:nil num:nil html-style:nil
#+INFOJS_OPT: view:info toc:nil path:chrome/org-info.js
#+AUTHOR: Jörg Kollmann
#+TITLE: My Emacs init
* Emacs Configuration

This configuration consists of three parts. In the first one, I'm collecting
all kinds of lisp functions. Some of them probably should be put into proper packages
instead. The second part defines global key bindings. This is the main
part, as the overall emacs behaviour is defined there.
In the third part, configurations for the packages I use are placed.

I'm not using =use-package=. I want to distribute my config over
several machines, so I'm setting config defaults in this file. Each
machine uses it's local =custom.el=, which is adopted by using the
=customize= functions and may or may not overwrite the defaults
defined here. To make this effective, the =custom.el= file is loaded
after this one has been processed.

Some nice customizations are still hidden in =custom.el= and probably
should be moved here..

** Lisp functions
*** Handling of other window

A topic of long and outstanding troubles has been the question
of seemingly eratically automatic selection of the /other window/.
While this is no problem when there is only one window in the current
frame, as soon as you craft a window configuration into your frame,
often the wrong window is chosen when a buffer should be pushed into
the /other window/.

As it seems, this selection of the other window is actually a quite
deterministic operation. Its frontend is ~pop-to-buffer~, the
implementation and documentation is in ~display-buffer~. There, a
range of ~display-buffer-functions~ can be combined at
will, generating this behaviour.

A first mitigation may be to sensibly change the
~display-buffer-fallback-action~, overriding it in
~display-buffer-base-action~. Here we just replace the
~display-buffer-use-some-window~ function which probably is the source of
those erratic behaviour. Our replacement is a combination of
~display-buffer-below-selected~ and ~display-buffer-at-bottom~, which on first
view seems to be not such a bad selection for frames using a large screen
space. This way, info/occur/magit windows which you want to pop up on
the fly are put below the window you are working in currently. Other
windows further down or at the sides are left untouched.

But we also need to make sure windows are not split if too small. We also
activate some further tweaks which are declared in the following sections.

First of all, here is the configuration, including changes to
~display-buffer-alist~, whose parts are introduced below.

Note: the order is relevant. When a deadgrep window is initiated from a dired
window, this is not an action going back to the dired origin. So all of the
initiating actions come first.

#+BEGIN_SRC emacs-lisp
  (custom-set-variables
   '(display-buffer-alist
     '(;; actions initiating a new selection window (so remember the origin)
       (new-buffer-is-dired-p maybe-make-dired-window-origin)
       ("\\*Occur\\*" make-buffer-window-origin)
       ("\\*deadgrep"
        (make-buffer-window-origin display-buffer-in-previous-window display-buffer-pop-up-window))
       ;; actions triggered from selection window (going back to the remembered origin)
       (current-window-is-dired-p
        (display-buffer-maybe-as-scroll-buffer display-dired-maybe-in-orig))
       ((lambda (buffer alist)
          (match-current-buffer "\\\\*Occur\\\\*")) display-buffer-in-orig)
       ((lambda (buffer alist)
          (match-current-buffer "\\\\*deadgrep")) display-buffer-in-orig)
       ;; other actions
       ("\\*Help\\*\\|\\*Apropos\\*\\|\\*Python Doc\\*"
        (display-buffer-as-scroll-buffer display-buffer-dedicated-window display-buffer-reuse-help display-buffer-at-bottom)
        (window-height . fit-window-to-buffer-max-half-frame))
       ("\\*ansi"
        display-buffer-at-bottom)))
   '(display-buffer-base-action
     '((display-buffer-maybe-as-scroll-buffer display-buffer-dedicated-window display-buffer--maybe-same-window display-buffer-reuse-window display-buffer--maybe-pop-up-frame-or-window display-buffer-in-previous-window display-buffer-below-selected display-buffer-at-bottom display-buffer-pop-up-frame)))
   '(window-min-height 8)
   '(window-min-width 40))
#+END_SRC

As a fallback we add a function to recursively edit with original behaviour.

#+BEGIN_SRC emacs-lisp
(defun edit-with-fallback-display ()
  "reset `display-buffer-base-action' and edit recursively, to
  have the original buffer sharing behaviour."
  (interactive)
  (let ((display-buffer-base-action nil))
    (recursive-edit)))
#+END_SRC

When constructing a display buffer alist, it can be useful to see the
arguments sent down the display action pipeline. Just put it into the alist
to get a logging in the message buffer.

#+BEGIN_SRC emacs-lisp
(defun display-show-args (buffer alist)
  "Write the current alist into the message buffer. Useful when debugging window handling."
  (message "display buffer '%s'\nwith alist:\n%s" buffer alist)
  nil)
#+END_SRC

**** Help and Apropos buffers

All help or apropos buffers to be pushed into the other window,
recognized by a regex, receive a special list if display actions and
also attributes modifying the window size. We want to put those
buffers into windows at bottom, where they are unobtrusive and can
stay as long as we want. If such a window already exists, it should be
reused. If a special dedicated window (see below) has been defined,
that should be used instead. The given ~display-height~ attribute
makes sure the window (also if reused) is shrunk to it's actual
contents. If it needs to be widened instead, this is done at max to
half of the frame size. This way, describing functions or variables
can be repeated as often as wished and the description always goes
into the same window, resizing it as needed.

#+BEGIN_SRC emacs-lisp
(defun window-apply-height-fnc (window alist)
  "rudimentary alist parser just accepting a height fnc for now.."
  (let ((height (cdr (assq 'window-height alist))))
    (if (functionp height)
        (ignore-errors (funcall height window)))
    window))

(defun window-update-buffer (buffer window type alist)
  "display buffer in window, recording type then apply height"
  (if (window--display-buffer buffer window type alist)
      (window-apply-height-fnc window alist)))

(defcustom help-buffer-regex "\\*Help\\*\\|\\*Apropos\\*"
  "regular expression defining which buffers should be recognized as help
buffers in `display-buffer-reuse-help'."
  :type '(string)
  :group 'my-cust)

(defun display-buffer-reuse-help (buffer alist)
  "If a *Help* or *Apropos* window is live, try to reuse that."
  (window-update-buffer buffer
                        (get-window-with-predicate
                         (lambda (w)
                           (string-match help-buffer-regex
                                         (buffer-name (window-buffer w)))))
                        'reuse alist))
#+END_SRC

Now we're defining a buffer-specific ~window-height~ action attribute only for
help and apropos buffers, specifying our custom function
~fit-window-to-buffer-max-half-frame~. This probably needs more tweaking to use less
than half frame height or also to use height of original window before split.

#+BEGIN_SRC emacs-lisp
(defun fit-window-to-buffer-max-half-frame (&optional window)
  "fit window to buffer size, but use max half of current frame height."
  (interactive)
  (let ((wnd (or window (selected-window)))
        (max-height (/ (frame-height) 2)))
    (fit-window-to-buffer window max-height)))
#+END_SRC

**** Dired and other file navigation buffers

The same should work in a similar way for ~dired~ buffers. But here is
more too do besides selecting a window for the dired buffer. If used
in the same window (e.g. via =C-x C-j=) , nothing to be done. But when
used in the other window (=C-x 4 C-j=), it should memorize its origin
window and put view buffers sent to /subsequent/ other windows there.
So ~dired~ can be opened in the other window (or be left there to be
reused later). When other files are selected and opened within the main
window (=o= or =C-o=), jumping forth and back between main and dired
window is easily possible.

First, some helper functions, setting and removing orig-window markers and
finding a window with a certain marker.

In ~ielm~, you can show the markers of the current window configuration using
something like this:
~(walk-windows (lambda (w)
    (print (window-parameter w 'orig-window))))~

#+BEGIN_SRC emacs-lisp
(defun clear-orig-window-marker (marker-or-buffer)
  "remove the given marker or buffer from any windows, so afterwards, no
window can be found containing this marker."
  (walk-windows (lambda (w)
                  (if (eq marker-or-buffer
                          (window-parameter w 'orig-window))
                      (set-window-parameter w 'orig-window nil)))))

(defun find-orig-window (marker-or-buffer)
  "find the first window whose `orig-window' parameter is set to the given
marker or buffer. If no such window is found, return nil."
  (get-window-with-predicate
   (lambda (w)
     (eq marker-or-buffer
         (window-parameter w 'orig-window)))))

(defun set-orig-window (window marker-or-buffer)
  "mark the given window as origin of operation specific to
buffer, removing the mark from other windows this buffer was
assgned to. This way, a dired buffer in other window can push its
subsequent other window view buffers into the origin window."
  (if (not (eq (window-buffer window) marker-or-buffer))
      (progn
        (clear-orig-window-marker marker-or-buffer)
        (set-window-parameter window 'orig-window marker-or-buffer))))
#+END_SRC

If a marked window exists, we want to be able to select it.

#+BEGIN_SRC emacs-lisp
(defun select-marked-orig-window (marker-or-buffer)
  "select the next window whose orig-window parameter is set to the given
marker or buffer."
  (let ((orig-window (find-orig-window marker-or-buffer)))
    (if (window-live-p orig-window)
        (select-window orig-window))))
#+END_SRC

If the ~other-window~ parameter of some window is a function, it will be used
to select a special other window instead of just the next one. So we provide a
funtion here that can do exactly this.

#+BEGIN_SRC emacs-lisp
(defun set-other-window-dired-orig (window)
  "setup `window' to have a :dired window as next window. If an arg is given
to the `other-window' function or that next window is not found, fall back
to default behaviour."
  (set-window-parameter window 'other-window
                        (lambda (count all-frames)
                          (if (and (= count 1)
                                   (select-marked-orig-window :dired))
                              't
                            (let ((ignore-window-parameters 't))
                              (other-window count all-frames))))))
#+END_SRC

The following functions can be used as display actions. There are two
functions. First, marking and remembering the originating window when a new
buffer is opened to display a dired/occur/... window. This action actually
doesn't select a window for the new buffer, only effecting this side effect.
Second, for new buffers opened from within dired, occur and so on, actual
actions selecting the previously marked buffer.

Both functions come in two flavors, the name ~maybe~ signalling that the alist
is respected when inhibiting usage of same window. The other one
unconditionally sends the new buffer to the marked window. This way, in
applications where you can decide whether to open a file in the same or in the
original window, this decision is respected (in ~dired~, for example, use =f=
or =RET= to open selected file in same window, =o= or =C-o= to open it in
other window). If an applications doesn't do this distinction, use the
function unconditionally selecting the other window.

#+BEGIN_SRC emacs-lisp
(defun make-buffer-window-origin (buffer alist)
  "use with a regex or matcher to memorize origin window. Then use
`display-buffer-in-orig' with same regex to push buffers to origin."
  (set-orig-window (selected-window) buffer)
  nil)

(defun maybe-make-buffer-window-origin (buffer alist)
  "if action attribute inhibit-same-window is given, store originating window."
  (if (cdr (assq 'inhibit-same-window alist))
      (make-buffer-window-origin buffer alist)))

(defun display-buffer-in-orig (buffer alist)
  "if a live orig window is defined, unconditionally use that to
  display the buffer."
  (let ((my-window (find-orig-window (current-buffer))))
    (if (and my-window (window-live-p my-window))
        (window-update-buffer buffer my-window 'reuse alist))))

(defun display-buffer-maybe-in-orig (buffer alist)
  "if action attribute inhibit-same-window is given and a live orig window is
defined, use that to display the buffer."
  (if (cdr (assq 'inhibit-same-window alist))
      (display-buffer-in-orig buffer alist)))
#+END_SRC

Now that the actions are defined, we need some predicates to select them.
First, a predicate using a regex to match buffer names. This way, you can
for example select buffer names beginning with "*Occur" to trigger an action
when a new occur buffer is opened. This one, actually generating the predicate
function, can be used in a backquote environment.

#+BEGIN_SRC emacs-lisp
(defun current-buffer-name-is-p (regex)
  "Does buffer name match the given regex?"
  `(lambda (buffer alist)
     (match-current-buffer ,regex)))
#+END_SRC

Helper function ~dired-p~ checks if a buffer has some ~dired-mode~. The
following two predicate functions check if the originating or the new buffer
is a dired buffer.

#+BEGIN_SRC emacs-lisp
(defun dired-p (buffer)
  "is buffer's major mode a dired mode?"
  (let ((mode (with-current-buffer buffer major-mode)))
    (string-match "dired-.*mode" (symbol-name mode))))

(defun new-buffer-is-dired-p (buffer alist)
  "match if new buffer is a dired buffer."
  (dired-p buffer))

(defun current-window-is-dired-p (buffer alist)
  "match if current buffer is a dired buffer."
  (dired-p (current-buffer)))
#+END_SRC

So when a ~new-buffer-is-dired-p~ matches, we need a function marking the
currently selected window as future origin for that new dired window.
What's the reason for this special variant btw?

#+BEGIN_SRC emacs-lisp
(defun make-dired-window-origin (buffer alist)
  "special case of `make-buffer-window-origin'. Use with a regex
or matcher to memorize origin window. Then use
`display-buffer-in-orig' with same regex to push dired buffers to
origin."
  (set-orig-window (selected-window) :dired)
  nil)

(defun maybe-make-dired-window-origin (buffer alist)
  "if action attribute inhibit-same-window is given, store originating dired window."
  (if (cdr (assq 'inhibit-same-window alist))
      (make-dired-window-origin buffer alist)))
#+END_SRC

And vice versa, when a ~current-window-is-dired-p~ matches, the new buffer should
be shown in the marked orig window. Besides that, we set up the dired window
to have the origin as next window (not sure though if this is useful).

#+BEGIN_SRC emacs-lisp
(defun display-dired-in-orig (buffer alist)
  "if a live orig window is defined, unconditionally use that to
display the dired buffer."
  (let ((my-window (find-orig-window :dired)))
    (if (and my-window (window-live-p my-window))
        (progn
          (set-other-window-dired-orig (selected-window))
          (window-update-buffer buffer my-window 'reuse alist)))))

(defun display-dired-maybe-in-orig (buffer alist)
  "if action attribute inhibit-same-window is given and a live orig window is
defined, use that to display the dired buffer."
  (if (cdr (assq 'inhibit-same-window alist))
      (display-dired-in-orig buffer alist)))
#+END_SRC

Here is a generalized matcher function, matching the current buffer.
Different applications use different strategies to display their buffers, so
you may need to use the ~display-buffer~-variants with or withour ~maybe~. See
customization at the beginning for an example addressing occur, this
way enabling using occur buffers in a similar way as dired.

#+BEGIN_SRC emacs-lisp
(defun match-current-buffer (regex)
  "match if regex matches current buffer."
  (string-match regex (buffer-name (current-buffer))))
#+END_SRC

**** Dedicated window

Use this to define a dedicated /other window/. Afterwards, the next
operation selecting another window will choose the dedicated one.
Optional arg allows to limit the dedication to the next ~n~ buffer
pushs. So prefix =C-1= makes a one time dedication, =C-0= removes a
dedication still lasting.

I often use this to override the split threshold variables, first splitting
in the direction I want, dedicating the new window and then calling
info/occur/dired ot whatever and letting it put it's buffer into the
other window.

#+BEGIN_SRC emacs-lisp
(defvar dedicated-other-window nil)
(defvar dedication-count)

(defun dedicate-window (arg)
  "Dedicate the currently selected window as 'other' window. When
called with a =C-0= prefix arg, releases the previously set
window and reverts to the default window selection behaviour. Default is a
one-time dedication, use =C-u= for unlimited."
  (interactive "p")
  (setq dedicated-other-window
        (if (eq arg 0)
            nil
          (selected-window)))
  (setq dedication-count
        (if (eq 4 arg) nil arg))
  (if dedicated-other-window
      (message "window dedicated")
    (message "dedication removed")))

(defun display-buffer-dedicated-window (buffer alist)
  "Display pop-up-buffer in the dedicated other window, if one is
selected. If none is selected, revert to the default behaviour."
  (if (and dedicated-other-window
           (window-live-p dedicated-other-window))
      (prog1
          (window-update-buffer buffer dedicated-other-window 'reuse alist)
        (if (and dedication-count (> dedication-count 0))
            (setq dedication-count (- dedication-count 1)))
        (if (eq 0 dedication-count)
            (setq dedicated-other-window nil)))))
#+END_SRC

**** Other window functions

This sorted out, I'm adding some useful functions for handling the other
window. Most of them are aimed at navigating text within the other
window without leaving the current window.

First, some functions making the behaviour of ~scroll-other-window~
and the =C-x4= functions more consistent. The other window should be remote
controllable as long as it is visible. When removed and no new buffer
pushed to another window, we will fall back to the remote controlling
behaviour selecting the next window.

#+BEGIN_SRC emacs-lisp
(defun display-buffer-as-scroll-buffer (buffer alist)
  "This action actually doesn't display a buffer, but records it
as `other-window-scroll-buffer'. It always returns nil so it can
be placed with highest priority."
  (setq other-window-scroll-buffer buffer)
  nil)

(defun display-buffer-maybe-as-scroll-buffer (buffer alist)
  "This action actually doesn't display a buffer, but records it as
`other-window-scroll-buffer', if the inhibit-same-window attribute
is given. It always returns nil so it can be placed with highest priority."
  (if (cdr (assq 'inhibit-same-window alist))
      (display-buffer-as-scroll-buffer buffer alist)))

(defun scroll-buffer-window ()
  "find window of `other-window-scroll-buffer', if live, or reset
other-window-scroll-buffer to nil, letting the other-window
functions fall back to default."
  (let ((scroll-window (get-buffer-window other-window-scroll-buffer)))
    (if (and (buffer-live-p other-window-scroll-buffer)
             (window-live-p scroll-window))
        scroll-window
      (setq other-window-scroll-buffer nil))))

(defun my-scroll-other-window ()
  "just like `scroll-other-window', but don't pop up the window
if not live."
  (interactive)
  (scroll-buffer-window) ; only for the side-effect of possibly resetting other-window-scroll-buffer
  (call-interactively #'scroll-other-window))

(defun my-scroll-other-window-down ()
  "just like `scroll-other-window-down', but don't pop up the window
if not live."
  (interactive)
  (scroll-buffer-window) ; only for the side-effect of possibly resetting other-window-scroll-buffer
  (call-interactively #'scroll-other-window-down))
#+END_SRC

A macro defining remote controlling functions, used in the following definitions.

#+BEGIN_SRC emacs-lisp
(defmacro nth-window (fname docstring &rest body)
  "Defines an interactive function performing the forms in BODY
 in other window or window specified by prefix arg. Uses FNAME as
 function name and describes it with DOCSTRING."
  `(defun ,fname (arg)
     ,docstring
     (interactive "P")
     (save-selected-window
       (select-other-window arg)
       ,@body)))
#+END_SRC

..and a function coding the logic to find the current other window. The
functions scrolling the other window (=C-M-v= etc) and my funtions
modifying the other window should behave consistently. Nevertheless, I
want my functions to behave like =C-x o=, where applying prefix args I
can jump to a specific window.

#+BEGIN_SRC emacs-lisp
(defun select-other-window (arg)
  "selects and returns the other window or window specified by prefix arg."
  (interactive "P")
  (let ((scroll-window (scroll-buffer-window)))
    (if (and (eq arg nil)
             other-window-scroll-buffer
             scroll-window
             (not (eq scroll-window (selected-window))))
        (select-window scroll-window)
      (call-interactively #'other-window)))
  (selected-window))

(defun find-other-window (arg)
  "finds the current other-window without actually selecting it."
  (interactive "P")
  (with-selected-window (selected-window)
    (call-interactively #'select-other-window)
    (selected-window)))
#+END_SRC

The same for frames might also come in handy.

#+BEGIN_SRC emacs-lisp
(defmacro nth-frame (fname docstring &rest body)
  "Defines an interactive function performing the forms in BODY
 in other frame or frame specified by prefix arg. Uses FNAME as
 function name and describes it with DOCSTRING."
  `(defun ,fname (arg)
     ,docstring
     (interactive "p")
     (let ((current (selected-frame)))
       (other-frame arg)
       ,@body
       (select-frame-set-input-focus current))))
#+END_SRC

**** Other window applications

And now some other-window-functions. The last one is generic: it allows to
jump to a window, work there and afterwards return. It also allows nested
jumps and returning with =C-M-c= or =C-]=.

#+BEGIN_SRC emacs-lisp
(nth-window go-back-other-window
  "Go back to previous help topic in other window."
  (help-go-back))

(nth-window quit-restore-other-window
  "Quit other window and deal with its buffer, possibly restoring
      the buffer previously displayed in other window."
  (quit-restore-window (selected-window)))

(nth-window shrink-other-window-if-larger-than-buffer
  "Shrink height of other window if its buffer doesn't need so many lines."
  (shrink-window-if-larger-than-buffer))

(nth-window beginning-of-other-window
  "Like `beginning-of-buffer-other-window', but use prefix arg to select window."
  (beginning-of-buffer))

(nth-window end-of-other-window
  "Like `end-of-buffer-other-window', but use prefix arg to select window."
  (end-of-buffer))

(nth-window jump-mark-other-window
  "jump to next mark from local mark ring."
  (pop-to-mark-command))

(nth-window jump-global-mark-other-window
  "jump to next mark from global mark ring."
  (pop-global-mark))

(nth-window kill-other-buffer-and-window
  "kill buffer in other window and delete that window."
  (kill-buffer-and-window))

(nth-window isearch-forward-other-window
  "do incremental search forward in other window."
  (isearch-forward))

(nth-window edit-other-window
  "recursively edit in other buffer, allowing to return later. Save
`other-window-scroll-buffer', reverting it after finishing."
  (let ((other-window-scroll-buffer
         (if (eq (scroll-buffer-window) (selected-window))
             nil
           other-window-scroll-buffer)))
    (recursive-edit)))
#+END_SRC

**** Push buffer to frame

Sometimes, auxiliary buffers to be displayed in the other window are
eratically pushed into some well arranged window. While this can be configured
through action variables used by ~display-buffer~, this is a complex and
error-prone configuration. To mitigate, use this function to push a buffer into its
own frame and revert the previously crafted window arrangement.

This also calls a little bit for some further 'remote control other frame'
functions..

#+BEGIN_SRC emacs-lisp
(defun push-buffer-to-frame ()
  "push current window buffer to own frame and revert current window to previous frame."
  (interactive)
  (let ((current (current-buffer))
        (selected (selected-window)))
    (if (display-buffer-other-frame current)
        (quit-restore-window selected))))
#+END_SRC

To make this work smoothly, we also change iconification of frames on close.

#+BEGIN_SRC emacs-lisp
(custom-set-variables
 '(frame-auto-hide-function #'delete-frame))
#+END_SRC

**** Misc

Split a window and select the new one. Use =C-u= to split vertically.

#+BEGIN_SRC emacs-lisp
(defun split-and-select-window (arg)
  "Split the current window and select the new one."
  (interactive "P")
  (if (eq arg nil)
      (split-window-below)
    (split-window-right))
  (other-window 1))
#+END_SRC

*** Convenient error stepping

You often want to navigate quickly through a list of error messages or
occurencies, jumping to the places the errors are indicating. There are
different ways to archieve this. First of all, you can activate
~next-error-follow-minor-mode~ (which in occur buffers is bound to =C-c C-f=),
allowing to move the mark through the error buffer, letting the referenced
source buffers follow you. Next, you can use =M-g M-n= or =M-g M-p= repeatedly
within the respective source buffer. Combined with =C-u=, resets to the first
error position and buffer. Also, ~next-error-select-buffer~ allows to select
an error buffer used for the next steps.

But if you want to have the respective source buffer active, you always need
to press these double key combinations, which is quite inconvenient. To ease
this, the following function is introduced. It also shows a cool feature of
setting a temporary keymap in place, allowing further navigation steps by
using shortcuts. This is quite convenient in the most different applications.
Here is a pattern often used my me as an example. When using =multi-occur= to
find a common regex within a project's files, arrange for a current file to be
displayed within a (selected) main window and multi-occur in another window.
Now just call =error-step= and navigate through the hits. This changes the
current file buffer within the main window as you go, so you may edit away as
this window is still selected.

Of course, the altenative is using =occur-edit-mode=, being similarly cool.

#+BEGIN_SRC emacs-lisp
(require 'cl)

(defun error-step ()
  (interactive)
  (macrolet ((step-msg ()
		       '(message "Use n,p,< to navigate further")))
    (step-msg)
    (set-transient-map
     (let ((map (make-sparse-keymap)))
       (dolist (modk '(() (meta)))
	 (define-key map (vector (append modk '(?n)))
	   (lambda () (interactive) (next-error) (step-msg)))
	 (define-key map (vector (append modk '(?<)))
	   (lambda () (interactive) (first-error) (step-msg)))
	 (define-key map (vector (append modk '(?p)))
	   (lambda () (interactive) (previous-error) (step-msg))))
       map) 't)))
#+END_SRC

*** Convenient Navigation Mode

This is another feature in the spirit of other window handling, activating
some kind of temporary navigation mode. Using this, you can conveniently
navigate, scroll, set marks and jump to previous mark positions in the other
window, without actually leaving the current window. Features include
scrolling up and down, jumping to begin and end of buffer, pagewise up and
down. Most of these can be combined with a numeric argument. The mode is
cancelled by using any other key.

#+BEGIN_SRC emacs-lisp
(defun navigate-buffer (&optional window)
  "Enter a temporary buffer navigation mode. WINDOW specifies an optional window pointer,
allowing to specify a remote window to be controlled."
  (lexical-let ((arg-acc 0) (arg-neg nil) (consumed nil)
		(window (or window (selected-window))))
    (labels ((set-consumed () (setq consumed 't))
	     (acc-reset ()
			(if consumed
			    (setq arg-acc 0 arg-neg nil consumed nil)))
	     (get-arg-acc (&optional default)
			  (let ((res (if (> arg-acc 0)
					 (* arg-acc (if arg-neg -1 1))
				       default)))
			    res))
	     (acc-status () (message "navigate ([-,0-9] n,p,v,V,<,>,[,],l, ) %c %d"
				     (if arg-neg arg-neg '? ) arg-acc))
	     (arg-negate ()
			 (setq arg-neg (if arg-neg nil '?-))
			 (acc-status))
	     (arg-accumulate (num)
			     (setq arg-acc (+ (* arg-acc 10) num))
			     (acc-status)))
      (macrolet ((with-window (&rest body)
			      `(lambda () (interactive)
				 (set-consumed)
				 (with-selected-window window
				   ,@body
				   (acc-status)))))
	(acc-status)
	(set-transient-map
	 (let ((map (make-sparse-keymap)))
	   (define-key map [?-] (lambda () (interactive) (acc-reset) (arg-negate)))
	   (dolist (num '(?0 ?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9))
	     (define-key map (vector num)
	       (lambda ()
		 (interactive)
		 (acc-reset)
		 (let* ((ev last-command-event)
			(base (event-basic-type ev)))
		   (arg-accumulate (- base 48))))))
	   (define-key map " " (with-window
				(if (eq arg-acc 0)
				    (progn (set-mark-command nil)(deactivate-mark))
				  (set-mark-command (get-arg-acc)))))
	   (define-key map "n" (with-window (scroll-up-line (get-arg-acc 1))))
	   (define-key map "p" (with-window (scroll-down-line (get-arg-acc 1))))
	   (define-key map "/" (with-window (isearch-forward))) ;not documented
	   (define-key map "l" (with-window (recenter-top-bottom (get-arg-acc))))
	   (define-key map "r" (with-window (move-to-window-line-top-bottom (get-arg-acc))))
	   (define-key map "<" (with-window (beginning-of-buffer (get-arg-acc))))
	   (define-key map ">" (with-window (end-of-buffer (get-arg-acc))))
	   (define-key map "]" (with-window (forward-paragraph (get-arg-acc))))
	   (define-key map "[" (with-window (backward-paragraph (get-arg-acc))))
	   (define-key map "\M-n" (with-window (next-line (get-arg-acc 1))))
	   (define-key map "\M-p" (with-window (previous-line (get-arg-acc 1))))
	   (define-key map "v" (with-window (scroll-up-command (get-arg-acc))))
	   (define-key map "V" (with-window (scroll-down-command (get-arg-acc))))
	 map) 't)))))

(defun navigate-window ()
  "like `navigate-other-window', but always use current window."
  (interactive)
  (navigate-buffer))

(nth-window navigate-other-window
  "Enter a temporary buffer navigation mode, allowing some window to be
controlled remotely. Default is the other window. Optional argument
selects the nth window. This allows moving around some window without
de-selecting the current window, enabling a very convenient means of
temporarily moving around. 

Keys are:
  -, 0-9: set an argument to following commands, which stays in effect until
          reset (e.g. by pressing 0)
  space: set a mark; with arg jump to mark
  n, p: scroll up/down
  l: recenter buffer to point
  r: move point to window center
  <, >: move point to beginning/end of buffer
  [, ]: move point forward/backward in paragraphs
  M-n, M-p: move point to next/previous line
  v, V: pagewise scroll up/down"
  (navigate-buffer))
#+END_SRC

*** Scrolling functions

When scrolling page wise, these functions help to control how much of the
previous page stays visible. ~scroll-slow~ leaves visible 90% of the previous
screen, doing only small scroll steps. ~scroll-fast~ still leaves 80%.
~scroll-halve~ jumps halve of the screen size. Each of them enable a recursive
edit, which can be cancelled with =C-M-c=.

Probably to be unified into a single function with argument..

#+BEGIN_SRC emacs-lisp
(defun scroll-fast ()
  "When scrolling pagewise, set the context lines to roughly 80% of screen height. This way, you need five steps to scroll one page."
  (interactive)
  (let ((next-screen-context-lines (round (* (frame-height) 0.8))))
    (recursive-edit)))

(defun scroll-slow ()
  "When scrolling pagewise, set the context lines to roughly 90% of screen height. This way, you need ten steps to scroll one page."
  (interactive)
  (let ((next-screen-context-lines (round (* (frame-height) 0.9))))
    (recursive-edit)))

(defun scroll-halve ()
  "When scrolling pagewise, set the context lines to roughly 50% of screen height. This way, you need two steps to scroll one page."
  (interactive)
  (let ((next-screen-context-lines (round (* (frame-height) 0.5))))
    (recursive-edit)))
#+END_SRC

*** Frame and window size

**** Window size

And another temporary pseudo mode, this time interactively resizing windows.

#+BEGIN_SRC emacs-lisp
(defun resize-window ()
  "Resize current window interactively using continuous key presses.
Keys supported:

 - shrink window vertically
 + enlarge window vertically
 { shrink window horizontally
 } enlarge window horizontally
 0 balance all frames window sizes"
  (interactive)
  (macrolet ((msg ()
		  '(message "resize window (-,+,{,},0)"))
	     (lmb (fnc)
		  `(lambda () (interactive)
		     (msg)
		     ,fnc)))
    (msg)
    (set-transient-map
     (let ((tmap (make-sparse-keymap)))
       (define-key tmap "0" (lmb (balance-windows)))
       (define-key tmap "-" (lmb (shrink-window 1)))
       (define-key tmap "+" (lmb (enlarge-window 1)))
       (define-key tmap "=" (lmb (enlarge-window 1))) ; easy access on us keyboard
       (define-key tmap "^" (lmb (enlarge-window 1))) ; reuse entry key
       (define-key tmap "&" (lmb (enlarge-window 1))) ; german keyboard
       (define-key tmap "{" (lmb (shrink-window-horizontally 1)))
       (define-key tmap "Ü" (lmb (shrink-window-horizontally 1))) ; german keyboard, here "U
       (define-key tmap "}" (lmb (enlarge-window-horizontally 1)))
       (define-key tmap "*" (lmb (enlarge-window-horizontally 1))) ; german keyboard
       tmap) 't)))
#+END_SRC

**** Frame size maximizing/auto-resizing

The following used to be a pseudo frame maximizing function for Mac,
which is no longer needed, since macos supports native full screen
modes. Instead we build a configurable solution toggling through
normal, maximized and visually attractive. "Visually attractive" would
then be something like "leave a small configurable space outside the
frame and use the rest of screen". For this, we use a customizable
variable constructing a list of frame styling functions. The functions
receive an argument list of (FRAME MAX-LINES MAX-COLS).

Note there is another function for switching to full size besides of this one.

#+BEGIN_SRC emacs-lisp
(defcustom my-frame-stylings nil
  "Frame styling functions used when toggling display frame size.
  After switching back from maximized size, each of the functions
  listed here is executed. There are functions to place the frame
  into a convenient position (e.g. left, right, middle of screen)
  and to resize it (like size just below threshold or size a
  little bit smaller than screen)."
  :type '(repeat function)
  :group 'my-cust)

(defun switch-frame ()
  "Set frame to reasonable position and size based on some heuristics.
  Alternatively, toggles size to maximized."
  (interactive)
  (let ((maximized (frame-parameter nil 'fullscreen))
        (confectioned (frame-parameter nil 'my-confectioned)))
    (cond
     ((eq confectioned 't)
      (let ((geom (frame-parameter nil 'my-geometry)))
        (set-frame-parameter nil 'my-confectioned nil)
        (set-frame-width nil (cadr geom))
        (set-frame-height nil (caddr geom))
        (set-frame-position nil (caar geom) (cdar geom))))
     ((eq maximized 'maximized)
      (let ((max-lines (frame-parameter nil 'height))
            (max-cols (frame-parameter nil 'width)))
	(set-frame-parameter nil 'fullscreen nil)
        (set-frame-parameter nil 'my-confectioned 't)
        (dolist (fnc my-frame-stylings)
                (funcall fnc (selected-frame) max-lines max-cols))))
     ((eq maximized nil)
      (set-frame-parameter nil 'my-geometry
                           (list (frame-position)
                                 (frame-width)
                                 (frame-height)))
      (set-frame-parameter nil 'fullscreen 'maximized)))))

(defun frame-width-below-threshold (frame lines cols)
  "Set frame with smaller than split width threshold. This way,
  info windows are split below. Otherwise, they might be split to
  the right."
  (set-frame-width frame (- split-width-threshold 1)))

(defun frame-width-dec (frame lines cols)
  "Set frame width a little bit smaller than display width."
  (set-frame-width frame (- cols 1)))

(defun frame-width-abs (frame lines cols)
  "Set frame width to absolute size of current frame"
  (let ((geom (frame-geom frame)))
    (let ((width (cadddr geom)))
      (set-frame-width frame width nil 't))))

(defun frame-height-dec(frame lines cols)
  "Set frame height a little bit smaller than display height."
  (set-frame-height frame (- lines 1)))

(defun frame-height-dec-two(frame lines cols)
  "Set frame height a little bit smaller than display height."
  (set-frame-height frame (- lines 2)))

(defun frame-geom (&optional frame)
  "Helper returning the current display geometry."
  (let ((current-display
         (car (remove-if-not
               (lambda (disp)
                 (let ((f (assq 'frames disp)))
                   (member (or frame (selected-frame)) f)))
               (display-monitor-attributes-list)))))
    (let ((geom (assq 'workarea current-display)))
      geom)))

(defun frame-to-left (frame lines cols)
  "Position frame to the left of current display. Works best when
  before frame is made smaller than maximized."
  (let ((geom (frame-geom frame)))
    (let ((x (cadr geom)))
      (set-frame-position frame
                          x
                          (cdr (frame-position frame))))))

(defun frame-to-top (frame lines cols)
  "Position frame to the top of current display. Works best when
  before frame is made smaller than maximized."
  (let ((geom (frame-geom frame)))
    (let ((y (caddr geom)))
      (set-frame-position frame
                          (car (frame-position frame))
                          y))))

(defun frame-to-center (frame lines cols)
  "Position frame to the center of current display. Works best when
  before frame is made smaller than maximized."
  (let ((geom (frame-geom frame)))
    (let ((x (cadr geom))
          (y (caddr geom))
          (width (cadddr geom))
          (height (cadr (cdddr geom))))
      (let ((dwidth (- width
                       (frame-pixel-width)))
            (dheight (- height
                        (frame-pixel-height))))
        (set-frame-position
         frame
         (+ x (round dwidth 2.1))
         (+ y (round dheight 2.1)))))))

(defun frame-to-right (frame lines cols)
  "Position frame to the right of current display. Works best when
  before frame is made smaller than maximized."
  (let ((geom (frame-geom frame)))
    (let ((x (cadr geom))
          (width (cadddr geom))
          (py (cdr (frame-position frame))))
      (let ((dwidth (- width
                       (frame-pixel-width))))
        (set-frame-position
         frame
         (+ x dwidth)
         py)))))

(defun frame-to-top-x11 (frame lines cols)
  "Position frame to the top of current x11 display. Works best when
  before frame is made smaller than maximized."
  (set-frame-position frame (car (frame-position frame)) 0))

(defun frame-to-second-x11 (frame lines cols)
  "(Questionable) function to position frame to the second x11
  display."
  (set-frame-position frame 1441 0))
#+END_SRC

**** Frame full screen switching

Here we toggle native fullscreen, removing all frame decorations and
transparency.

#+BEGIN_SRC emacs-lisp
(defcustom enter-maximize-frame-hook
  '((lambda nil
    (display-time-mode 1))
  (lambda nil
    (switch-frame-transparency nil)))
  "hook executed when maximizing a frame"
  :type '(repeat function)
  :group 'my-cust)

(defcustom exit-maximize-frame-hook
  '((lambda nil
    (display-time-mode 0))
  (lambda nil
    (switch-frame-transparency 't)))
  "hook executed when normalizing a frame"
  :type '(repeat function)
  :group 'my-cust)

(defun toggle-maximize-frame ()
  "Toggle fullscreen and switch off menu bar and scroll bar."
  (interactive)
  (let ((fullscreen (frame-parameter nil 'fullscreen)))
    (cond
     ((memq fullscreen '(fullscreen fullboth))
      (dolist (fnc exit-maximize-frame-hook)
        (funcall fnc))
      (toggle-frame-fullscreen))
     ((eq fullscreen nil)
      (dolist (fnc enter-maximize-frame-hook)
        (funcall fnc))
      (toggle-frame-fullscreen)))))

(defun switch-frame-transparency (state)
  (cond
   (state
    (apply (get 'my-frame-transparency 'custom-set) 'my-frame-transparency
           (frame-parameter nil 'my-transparency) nil)
    (set-frame-parameter nil 'my-transparency nil))
   ('t
    (set-frame-parameter nil 'my-transparency my-frame-transparency)
    (apply (get 'my-frame-transparency 'custom-set) 'my-frame-transparency 100 nil))))
#+END_SRC

*** Frame Transparency

I like to have an easy way of setting and changing colors and
transparency for all frames, this way having a consistent appearance
on each machine. More easy then defining themes, still contradicts
them a little bit..

#+BEGIN_SRC emacs-lisp
(defgroup my-cust nil "my customizations")
(defcustom my-frame-transparency 100
  "transparency used for all display frames."
  :type '(integer)
  :group 'my-cust
  :set (lambda (symb val)
         (setq my-frame-transparency val)
         (dolist (frame (frames-on-display-list))
           (set-frame-parameter frame 'alpha `(,val . ,val)))))
(defcustom my-frame-background "Black"
  "background color used for all display frames."
  :type '(string)
  :group 'my-cust
  :set (lambda (symb val)
         (setq my-frame-background val)
         (dolist (frame (frames-on-display-list))
           (with-selected-frame frame
             (set-background-color my-frame-background)))))
(defcustom my-frame-foreground "Green"
  "foreground color used for all display frames."
  :type '(string)
  :group 'my-cust
  :set (lambda (symb val)
         (setq my-frame-foreground val)
         (dolist (frame (frames-on-display-list))
           (with-selected-frame frame
             (set-foreground-color my-frame-foreground)))))

(add-hook 'after-make-frame-functions
	  (lambda (frame)
	    (set-frame-parameter frame 'alpha (cons my-frame-transparency my-frame-transparency))
	    (with-selected-frame frame
	      (set-background-color my-frame-background)
	      (set-foreground-color my-frame-foreground))))
#+END_SRC

*** electric delimiter

Often I want to put some text into delimiters after writing it, for example a
string or an argument list. So the reverse of a splicing operation is needed.
This is a wrapper around ~insert-pair~, so the prefix arg works selecting the
next or previous entities to surround. Alternatively, the region is used.
Respects ~insert-pair-alist~ to determine the closing character.

#+BEGIN_SRC emacs-lisp
(defun my-delimit-region (pre bd)
  "Frame region or entities selected by prefix with delimiters.
If delim is an opening type of brace, automatically use the
corresponding closing delimiter using `insert-pair-alist'.
If called interactively, take next key press as
opening delimiter."
  (interactive "P\nc")
  (let ((pair (assq bd insert-pair-alist))
        (open bd) (close bd))
    (if pair
        (if (nth 2 pair)
            (setq open (nth 1 pair) close (nth 2 pair))
          (setq open (nth 0 pair) close (nth 1 pair))))
    (insert-pair pre open close)))
#+END_SRC

** Environment Minor Mode

We want to easily be able to switch between different environments. For
example, when using a notebook in mobile or in docked mode, you may
have a mouse or trackpad, apple or pc keyboard at hand. Each of
them needs other custom configurations, which should be easily
switable when changing the environment. This is implemented in a global minor mode,
binding a hot key as environment toggle. Each environment is designated by an
id character shown in the mode line and a list of actions. Each action has
enter and exit functions to setup and leave the corresponding action. This
way, actions can be defined in terms of (lambda) functions. Also an action can
be part of different environments.
After customizing the mode, use =C-c C-\= to toggle through environments.

#+BEGIN_SRC emacs-lisp
(defgroup my-environment nil "my environments")

(defcustom my-env-actions nil
  "list of actions. Each element has the form (symb enter-fnc
exit-fnc), where symb is a symbol used to address this definition, enter-fnc
and exit-fnc are functions to setup and leave the corresponding state."
  :type '(repeat (list symbol function function))
  :group 'my-environment)

(defcustom my-env-definitions nil
  "list of environments to toggle through. Each definition has the form (id
(list of symbols)), where id is a character shown in the mode
line describing the current environment. Then follows a list of
action symbols. Each of these actions is entered when
environment is toggled on and exited when another environment
is selected. If only one env is defined, toggles between this
only, so you should probably at least define a second env with
a default N id and no actions."
  :type '(repeat (list character (repeat symbol)))
  :group 'my-environment)

(defun my-env-init-keymap ()
  "setup a keymap for my-environment-mode, inserting the env toggle hot key."
  (define-prefix-command 'my-env-map)
  (let ((kmap (make-sparse-keymap)))
    (define-key kmap "\C-c" my-env-map)
    (define-key my-env-map "" #'toggle-my-environment)
    kmap))

(defun my-env-add-map (kmap)
  "Use this function in your enter action definitions to add sparse keymaps to the current environment."
  (pushnew kmap my-env-maps))

(defun my-env-remove-map (kmap)
  "Use this function in your exit action definitions to remove sparse keymaps from the current environment."
  (setq my-env-maps (remote-if (lambda (elem)
                                 (eq elem kmap))
                               my-env-maps)))

(define-minor-mode my-environment-mode
  "Minor mode supporting easy switching between different environments. For
example, using a notebook in mobile or in docked mode may mean using mouse or
trackpad, apple or pc keyboard.

\\{my-environment-mode-map}"
  nil
  " [N]"
  (my-env-init-keymap)
  :group 'my-environment
  :global 't
  :after-hook (toggle-my-environment))
#+END_SRC

You may add key definitions in enter action
functions with ~my-env-add-map~.
To remove them on exit, if you dont declare an exit function, as a convenience
use =my-env-reset-keymap=.

#+BEGIN_SRC emacs-lisp
(defun my-env-reset-keymap ()
  "If your enter function added to the minor mode or my-env keymaps, your exit
function should call this function to reset it."
  (setq my-env-maps nil))
#+END_SRC

*** Internals

#+BEGIN_SRC emacs-lisp
(defvar my-env-action nil) ; current env cell. car is the env, cdr the next cell..

(defvar my-env-maps nil) ; list of maps to combine into current env
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my-env-update-parent-map ()
  "creates a parent for the minor mode composing all current action maps."
  (set-keymap-parent my-environment-mode-map (make-composed-keymap my-env-maps)))

(defun my-env-enter-action (action)
  "calls the enter definition of given action if provided."
  (let ((aclist (remove-if-not (lambda (elem)
                                 (eq action (car elem)))
                               my-env-actions)))
    (if (and aclist (cadar aclist))
        (funcall (cadar aclist)))))

(defun my-env-exit-action (action)
  "calls the exit definition of given action if provided."
  (let ((aclist (remove-if-not (lambda (elem)
                                 (eq action (car elem)))
                               my-env-actions)))
    (if (and aclist (caddar aclist))
        (funcall (caddar aclist)))))

(defun toggle-my-environment ()
  "toggles activation of next environment. If only one env is defined, toggles
between this only, so you should probably at least define a second env with a
default N id and no actions."
  (interactive)
  (let ((current my-env-action)
        (next
         (if (not my-env-action)
             my-env-definitions
           (let ((next-first
                  (cdr my-env-action)))
             (if (not next-first)
                 my-env-definitions
               next-first)))))
    (if current
        (let ((env (car current)))
          (dolist (action (cadr env))
            (my-env-exit-action action))))
    (if next
        (let ((env (car next)))
          (dolist (action (cadr env))
            (my-env-enter-action action))
          (my-env-update-parent-map)
          (my-env-update-lighter (format " [%c]" (car env)))))
    (setq my-env-action next)))

(defun my-env-update-lighter (lighter)
  "update the lighter of minor mode to reflect the selected environment."
  (setcar
   (cdar (remove-if-not (lambda (elem)
                          (eq (car elem) 'my-environment-mode))
                        minor-mode-alist))
   lighter)
  (force-mode-line-update 't))
#+END_SRC

** Global key bindings

Controlling emacs works best with the ability of touch typing, combined with a
sensible selection of modifier keys. Repetitive strain injury can be prevented
by using the hand not typing to hold modifier keys. At least to a certain degree,
this counteracts the emacs philosophy of continuously holding a modifier while
pressing a continuous key path. So often it is more practical to use one hand
holding the modifier (in my case this is often the left one) while using the
other one going over the full keyboard. Nevertheless, it is useful to have all
modifier keys on both sides.

Remembering the space cadet keyboard, you find all of the modifiers both on
the left and on the right of space bar. This can be done in a similar fashion
on today's pc keyboards, using ctrl, cmd and alt for the /Control/, /super/
and /Meta/ modifiers on the left, to be used with 4th, 3rd and 2nd left
finger. On the right, I'm using alt as it is, cmd and ctrl for the /Meta/ and
/Control/ modifiers (similarly to be used with 2nd and 4th right finger). This
way, I can always have one hand on a modifier block.

Of course this leads to a considerable re-wiring of long learned muscle
memory. On the other side, the hope is to also considerably ease fast emacs
handling this way. For example, I'm observing me starting to prefer =C-m= to =RET=,
being easier within reach when having left hand on the modifier row.

Still, it is often easier to press combinations on the left side one handed
(like =C-x C-s=). To do these holding /Control/ with the small finger, it is
also adviced to define caps lock as /Control/. Doing the left-hand moves then
gets quite easy. Time will tell if usage of these one-handed combinations will
be replaced by the more healthy two-handed counterparts.

*** Generic

Some convenience keys for handling buffers and files. Use caution and check to
not shadow future default functionality here.
We replace =C-x C-f= with ~find-file~, as the ~-at-point~ function is then
still reachable through =M-n=. The old mapping of =C-c C-f= to
~find-file-at-point~ is removed, as it is now overlayed by org.
Probably the idea of having =M-x= also on a /Control/ binding proves to be practical.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x\C-b" #'bs-show)	;; this used to be electric-buffer-list
(global-set-key "\C-x\C-f" #'find-file)
(global-set-key [3 67108919] #'toggle-my-environment)  ;; make global to enable env switch on german kbd
(global-set-key [24 67108877] 'execute-extended-command) ;; C-x C-RET
#+END_SRC

Having the repeat commands more within reach also proves to be very helpful:

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x\C-z" #'repeat)
(global-set-key [201326651] #'repeat-complex-command)  ;; C-M-;
(global-set-key [201326650] #'repeat-complex-command) ;; C-M-:
#+END_SRC

And my delimiting function, experimentally also replacing ~insert-parenthesis~
on =M-(=:

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cF" #'my-delimit-region)
(global-set-key [remap insert-parentheses] #'my-delimit-region)
#+END_SRC

Moving through paragraphs put somewhat easier into reach:

#+BEGIN_SRC emacs-lisp
(global-set-key "\M-[" #'backward-paragraph)
(global-set-key "\M-]" #'forward-paragraph)
#+END_SRC

expand-region may come handy, additionally to the explicit selection
commands. We put it on =C-c h= and =SPC=, similar to other selection commands
using =h= or =SPC=.

#+BEGIN_SRC emacs-lisp
(require 'expand-region)
(global-set-key "\C-ch" 'er/expand-region)
(global-set-key " " 'er/expand-region)
#+END_SRC

Split window and select new one. With prefix arg, split vertically.

#+BEGIN_SRC emacs-lisp
(global-set-key [24 67108914] #'split-and-select-window)  ;; C-x C-2
(global-set-key "\C-x42" #'split-and-select-window)
#+END_SRC

*** Convenience for searching

This one really is a small hidden diamond. Often you want to finish a
search leaving the point on the first character of the string found.
As each search also positions the mark at it's origin, by executing
adjacent searches you can easily select a region. This enables using
isearch as a convenient tool not only for navigating, but also for
selecting or killing. This is enabled here on =C-return=. So you start
a search, typing ahead until you reach the desired location, =C-RET=
and hit the desired spot. Repeating it selects the region between both
spots. Make it visible with =C-x C-x=.

#+BEGIN_SRC emacs-lisp
(define-key isearch-mode-map (kbd "<C-return>")
  (lambda () (interactive)
    (isearch-repeat (if isearch-forward
                        'backward
                      'forward))
    (isearch-exit)))
#+END_SRC

*** Scrolling and Navigation

Convenience keys for buffer scrolling. Enables up/down also with /Meta/
modifier. Together with /Shift/ this enables scrolling. This way you can very
conveniently move the pointer and scroll by just adding/releasing the /Shift/
modifier. When ~visual-line-mode~ is activated, the /Meta/ keys act on the
logical lines.

Similar keys for word navigation. As usual, =M-f= and =M-b= navigates over
words. When combined with /Shift/, navigates to the end/beginning of words. 

#+BEGIN_SRC emacs-lisp
(require 'misc)
(global-set-key "\M-p" #'previous-logical-line)
(global-set-key "\M-n" #'next-logical-line)
(global-set-key "\M-P" #'scroll-down-line)
(global-set-key "\M-N" #'scroll-up-line)
(global-set-key "\M-F" #'forward-to-word)
(global-set-key "\M-B" #'backward-to-word)
(global-set-key [end] #'move-end-of-line)
(global-set-key [home] #'move-beginning-of-line)
#+END_SRC

*** Ace zapping

Ace enables some more vi-style jumping and zapping. But not working
iteratively, it's not really nicely integrating with typical emacs workflows.
Actually better proved to be using isearch (also with customized =M-RET=). So
we are probably going to remove ace.

But additionally to =M-z= (the basic ~zap-to-char~ function), we are adding =M-Z=
for ~zap-up-to-char~. Both of them can be nicely repeated or provided with an
prefix arg.

#+BEGIN_SRC emacs-lisp
(global-set-key "\M-Z" #'zap-up-to-char)
#+END_SRC

*** Mouse handling

Mouse keys: remember basic mouse button handling in emacs: left - set pointer,
double left - select word, triple left - select line, drag - select, drag
after double - select words, right - define region and save to kill ring,
right after double click - define region up to next word, double right - kill
to kill ring, middle - yank to click position.

On Mac, we yank with /Control/ and /Meta/.

#+BEGIN_SRC emacs-lisp
(defun mac-mouse-yank ()
  "yank with mouse button."
  (let ((kmap (make-sparse-keymap)))
    (define-key kmap (kbd "<C-M-mouse-2>") #'yank)
    (my-env-add-map kmap)))
#+END_SRC

Additionally, you can double click on delimiters like parens or quotes to
select the delimited text. Finally, we activated the drag and drop feature.

~mouse-wheel-mode~ also enables mouse wheel scrolling. With /Meta/,
enables scroll turbo; with /shift/, scale text (seems to work only on
trackpad, as it is mapped to =S-wheel-left= / =right=).

To revert yanks when hand on mouse, we place ~undo~ on =M-mouse-2=. Probably
no more customizations to be done. Especially when using the trackpad, hands
are already near keyboard.
Should be activated by customizing into my-environment-mode.

#+BEGIN_SRC emacs-lisp
;; mac trackpad: select: mouse-1, copy/cut: mouse-3, yank: M-mouse-3
;; undo: C-M-mouse-3
;; as a convenience, on mode line M-mouse-1 is also mouse-2
;; (define-key key-translation-map (kbd "<M-mouse-3>") (kbd "<mouse-2>"))
;; (global-set-key [C-M-mouse-3] 'undo)
;; (define-key key-translation-map (kbd "<mode-line> <M-mouse-3>") (kbd "<mode-line> <mouse-2>"))
;; (define-key key-translation-map (kbd "<mode-line> <M-mouse-1>") (kbd "<mode-line> <mouse-2>"))
;; (global-set-key [M-mouse-3] #'mouse-yank-at-click)
;; mac mouse: select: mouse-1, copy/cut: mouse-3, yank: M-mouse-2,
;; undo: M-mouse-3
;; (global-set-key [M-mouse-2] #'mouse-yank-at-click)
;; (global-set-key [M-mouse-3] #'undo)
(defun mouse-undo ()
  "undo with mouse button."
  (let ((kmap (make-sparse-keymap)))
    (define-key kmap (kbd "<M-mouse-2>") #'undo)
    (my-env-add-map kmap)))
#+END_SRC

When using a mouse wheel, we also want to use the text size zooming feature which
in wheel-mode apparently works only with trackpad.

#+BEGIN_SRC emacs-lisp
(defun my-wheel-zoom ()
  (let ((kmap (make-sparse-keymap)))
    (define-key kmap (kbd "<S-wheel-right>") #'text-scale-increase)
    (define-key kmap (kbd "<S-wheel-left>") #'text-scale-decrease)
    (my-env-add-map kmap)))

(defun my-x11-wheel-zoom ()
  (let ((kmap (make-sparse-keymap)))
    (define-key kmap (kbd "<S-mouse-5>") #'text-scale-increase)
    (define-key kmap (kbd "<S-mouse-4>") #'text-scale-decrease)
    (my-env-add-map kmap)))
#+END_SRC

*** Keyboard handling

On a us keyboard, we also want to be able to use german umlauts. This is
possible quite easily, courtesy of mule. =C-\= switches the default input
method on and off, so zou can activate it on your finger tips. Additionally,
select the default input method with =C-x RET C-\=. Practical are
/german-postfix/ (ae), /german-prefix/ ("a) or /german/ - the latter
activating a complete german keymapping, which is probably not too useful on a
us keyboard. Input methods are described by =C-h I=.

On a german keyboard, we want some of the more obscure mappings to be within
easier reach. This is done here for combinations otherwise unmapped.
Should be activated by customizing into my-environment-mode.
Augment as needed..

#+BEGIN_SRC emacs-lisp
(defun activate-german-keymap ()
  "activate some generic mappings to be reachable in usual places on german keyboard."
  (let ((kmap (make-sparse-keymap)))
    (define-key kmap "\242" #'mark-word) ; M-@, here M-"
    (define-key kmap "\246" #'delete-indentation) ; M-^, here M-&
    (define-key kmap "\C-x&" #'enlarge-window) ; C-x ^, here C-x &
    (define-key kmap "\C-x*" #'enlarge-window-horizontally) ; C-x }
    (define-key kmap "\C-xÜ" #'shrink-window-horizontally)  ; C-x {
    (define-key kmap [3 67108919] #'toggle-my-environment)
    (my-env-add-map kmap)))
#+END_SRC

**** Modifiers

The /Meta/ key should always be directly left and right of the space
bar. At least on the right side, there should be an /Alt/ key.
/Control/ should be also on the shift lock (defined on os level).
Additional keys may be mapped to /super/. Uses of /super/ and /hyper/
are to be explored.

On an Apple keyboard, we want to use the command keys as /Meta/, the
right alt as option, control as such and probably the left alt as
/super/. Btw, note you can get the /tilde/ with =S-A-8=.

#+BEGIN_SRC emacs-lisp
(defun on-apple-keyboard ()
  (custom-set-variables
   '(ns-control-modifier 'control)
   '(ns-alternate-modifier 'super)
   '(ns-right-alternate-modifier 'alternate)
   '(ns-command-modifier 'meta)
   '(ns-right-command-modifier 'meta)))
#+END_SRC

Similarly, on a PC keyboard, the left alt is /Meta/, the right als
used as /AltGr/.

#+BEGIN_SRC emacs-lisp
(defun on-pc-keyboard ()
  (custom-set-variables
   '(ns-control-modifier 'control)
   '(ns-alternate-modifier 'meta)
   '(ns-right-alternate-modifier 'alternate)
   '(ns-command-modifier 'super)
   '(ns-right-command-modifier 'meta)))
#+END_SRC

*** Window handling

We overrule =C-x ^= to use our window resizing method.

#+BEGIN_SRC emacs-lisp
(global-set-key [remap enlarge-window] #'resize-window)
#+END_SRC

And upgrade fullscreen experience. Use =M-F10= to toggle between maximized
and a size comprised of almost full height and a width just below
~split-width-threshold~; =M-F11= to toggle fullscreen including no window
decorations.

#+BEGIN_SRC emacs-lisp
(global-set-key [remap toggle-frame-fullscreen] #'toggle-maximize-frame)
(global-set-key [remap toggle-frame-maximized] #'switch-frame)
(global-set-key (kbd "<M-f11>") #'toggle-maximize-frame)
#+END_SRC

*** Remote controlling other window

As I got quite used to remote control the other window using =C-x 4= keys, 
I'm adding a few ones which I missed so far.
Note emacs 28 adds =1= and =4= to push next buffer into current respective
into other window.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x4q" #'quit-restore-other-window)
(global-set-key "\C-x4l" #'go-back-other-window)
(global-set-key "\C-x4-" #'shrink-other-window-if-larger-than-buffer)
(global-set-key "\C-x4s" #'dedicate-window)
(global-set-key "\C-x4\C-s" #'isearch-forward-other-window)
(global-set-key "\C-x4e" #'edit-other-window)
(global-set-key "\C-x4k" #'kill-other-buffer-and-window)
#+END_SRC

Note the window size changing keys, =C-x ^= to enlarge (also negative) and
=C-x -= to shrink if buffer is smaller than window are a little bit asymetric.
While the enlargement key can be used to enlarge and shrink the current
window, the shrink key works only in one direction. So here we define an
adjacent key for the other window. For rescue, there is always =C-x += to
balance windows.

We also want to jump to beginning/end in other window by =C-M-<= and =C-M->=
(cf. =C-M-v= and =C-M-V= to scroll pagewise in other window).

#+BEGIN_SRC emacs-lisp
(global-set-key [201326652] #'beginning-of-other-window)
(global-set-key [201326654] #'end-of-other-window)
(global-set-key "\C-x4<" #'beginning-of-other-window)
(global-set-key "\C-x4>" #'end-of-other-window)
(global-set-key "\C-x4 " #'jump-mark-other-window)
(global-set-key [24 52 24 67108896] #'jump-global-mark-other-window)  ;; C-x 4 C-x C-SPC
(global-set-key [remap scroll-other-window] #'my-scroll-other-window)
(global-set-key [remap scroll-other-window-down] #'my-scroll-other-window-down)
#+END_SRC

How to get these codes? Call =M-x global-set-key RET C-M-< beg=.. to manually
define such a key, then call =C-x ESC ESC= and copy the resulting parametrized
command from minibuffer.
Alternatively, call =M-: (read-key-sequence "> ")=.

Now comes the key binding for convenient error navigation whose
function was defined above.

#+BEGIN_SRC emacs-lisp
(define-prefix-command 'other-goto-map)
(global-set-key "\C-x4\M-g" 'other-goto-map)
(define-key other-goto-map "\M-n" #'error-step)
#+END_SRC

Here we bind the temporary navigation mode to some useful keys for current and
other window.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x\C-v" #'navigate-window)
(global-set-key "\C-x4v" #'navigate-other-window)
#+END_SRC

*** Remote controlling other frame

Push current window buffer to own frame and revert current window to previous frame.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x5p" #'push-buffer-to-frame)
#+END_SRC

** Misc

How emacs finds its tools:

#+BEGIN_SRC emacs-lisp
(setenv "PATH" (concat "/opt/local/bin:/opt/local/sbin:" (getenv "PATH")))
#+END_SRC

Load and enable different additional packages

#+BEGIN_SRC emacs-lisp
(setq org-element-use-cache nil)  ;; temporarily disable org element cache
(load-library "realgud")
(load-library "evil")
(require 'wdired)  ;; edit dired buffers with C-x C-q
(load "dired-x.el") ;; also enable dired-jump with C-x C-j
(require 'helm-config)
(require 'ox-rst)
(require 'yaml-mode)
(global-undo-tree-mode)
;;(global-magit-file-mode t)
(which-key-mode 1)  ;; not only for spacemacs..

(setq erc-autojoin-channels-alist '(("freenode.net" "#latex-de" "##latinitas" "#NetBSD" "##bash-de" "#git" "#vim" "#emacs" "#erc" "#oberon" "#macosx")))
(define-key global-map [ns-drag-file] 'ns-find-file)

;; sink for ancient commands
;;(set-background-color "ARGBccffffff")
;;(require 'ns-platform-support)
;;(ns-extended-platform-support-mode)

(global-set-key [(f1)] (lambda()(interactive)(manual-entry (current-word))))
;; (setq gc-cons-threshold 1000000)  ;; re-evaluate
;; re-evaluate bell handling
;;(setq inhibit-startup-message t)
;; visible bell workaround for el capitan
;;(setq visible-bell t)
(setq visible-bell nil) ;; The default
(setq ring-bell-function 'ignore)
;; end of workaround
;;(standard-display-european 1)
;;(require 'iso-syntax)
;;(setq minibuffer-max-depth nil)  ;; what's this?
#+END_SRC

Accept simplified answers.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Mode-specific customizations
*** dired
**** convenience
In dired, to select a file or directory, often it is easier to type =C-m=
than =RET= (because easier within reach of base row than the ret key, being
two keys away). To get up a directory in the opposite direction via =^= is
also not within easy reach. So going up also with =;= and =C-,= seems
reasonable. BTW, selecting a file or directory is also possible with =f= and
=e=.

#+BEGIN_SRC emacs-lisp
(define-key dired-mode-map "," #'dired-up-directory)
(define-key dired-mode-map ";" #'dired-up-directory)
(define-key dired-mode-map "ö" #'dired-up-directory)  ;; on german keyboard same key like ;
(define-key dired-mode-map [67108908] #'dired-up-directory)
#+END_SRC

**** dired-ediff
Enable simple access to  ~ediff~ within ~dired~. Select two files with
mark and point, then press ~=~ to compare.

#+BEGIN_SRC emacs-lisp
(define-key dired-mode-map "="
  (lambda ()
    "ediff file at mark and file at point."
    (interactive)
    (let ((file (dired-get-filename))
          (prev (if mark-active 
                    (save-excursion (goto-char (mark t))(dired-get-filename))
                  nil)))
      (if (and file prev)
          (ediff-files prev file)))))
#+END_SRC

**** dired-multi-occur
As suggested by Nicolas Petton
(https://nicolas.petton.fr/blog/mutli-occur-on-projects.html), selecting files
as source for =multi-occur= can be handy. This is done here:

#+BEGIN_SRC emacs-lisp
(defun dired-occur (regexp &optional nlines)
  "Perform `multi-occur' with REGEXP in all dired marked files.
When called with a prefix argument NLINES, display NLINES lines before and after."
  (interactive (occur-read-primary-args))
  (multi-occur (mapcar #'find-file (dired-get-marked-files)) regexp nlines))

(define-key dired-mode-map "\C-c\C-o" #'dired-occur)
#+END_SRC

Besides that, using the =ibuffer= multi-occur feature to search in buffers is
also handy.

*** deadgrep

deadgrep-mode is missing some typical navigational features like =next-error=,
=previous-error=. Also it needs a function only displaying a result, not
visiting it. These are provided here. Used in combination with a corresponding
=display-buffer-alist=, this allows to easily navigate through the matches,
displaying them in the other window.

#+BEGIN_SRC emacs-lisp
(defun deadgrep-display-result-other-window ()
  "display currently selected match in some buffer in other window, but don't visit/select."
  (interactive)
  (let ((current-window (selected-window)))
    (deadgrep-visit-result-other-window)
    (select-window current-window)))

(defun deadgrep-display-result ()
  "display currently selected match in some buffer, but don't visit/select."
  (interactive)
  (let ((current-window (selected-window)))
    (deadgrep-visit-result)
    (select-window current-window)))

(defun deadgrep-display-next (arg reset)
  "display next match and don't select it."
  (interactive)
  (message "%s" arg)
  (let ((fnc (if (> arg 0)
                 #'deadgrep-forward-match
               #'deadgrep-backward-match)))
    (loop repeat (abs arg)
          do (funcall fnc)))
  (deadgrep-display-result))

(defun deadgrep-display-prev ()
  "display previous match and don't select it."
  (interactive)
  (deadgrep-backward-match)
  (deadgrep-display-result))

(add-hook 'deadgrep-mode-hook
          (lambda ()
            (setq next-error-function #'deadgrep-display-next)
            ;; (define-key deadgrep-mode-map "\M-g\M-n" #'deadgrep-display-next)
            ;; (define-key deadgrep-mode-map "\M-g\M-p" #'deadgrep-display-prev)
            (define-key deadgrep-mode-map "\C-o" #'deadgrep-display-result-other-window)))
#+END_SRC

*** org
**** org present

Org present presents each top level element as a page. It only has a few
simple keys. Use left/right to go through the presentation, =C-c <= and =C-c
>= for first and last page. Switch to large presentation mode and back by =C-c
C-== and =C-c C--=. Quit the presentation with =C-c C-q=.

=org-present= shows the presentation in a normal window, allowing it to be
used besides other windows and also to change it's contents while presenting.
For a full presentation, use the =my-org-present-full= command. Switch back
with the corresponding =tiny= command.

#+BEGIN_SRC emacs-lisp
(defun my-org-present-full ()
  (interactive)
  (progn
    (add-hook 'org-present-mode-hook
              (lambda ()
                (org-present-big)
                (org-display-inline-images)
                (toggle-frame-fullscreen)
                (org-present-hide-cursor)
                (org-present-read-only)
                (turn-on-hide-mode-line-mode)))
    (add-hook 'org-present-mode-quit-hook
              (lambda ()
                (turn-off-hide-mode-line-mode)
                (org-present-small)
                (org-remove-inline-images)
                (toggle-frame-fullscreen)
                (org-present-show-cursor)
                (org-present-read-write)))))

(defun my-org-present-tiny ()
  (interactive)
  (setq org-present-mode-hook nil)
  (setq org-present-mode-quit-hook nil))
#+END_SRC

*** Evil mode

**** Evil defines

Here we implement some kind of =.vimrc= initialization.
This is also an example of defining an evil leader key and some adjacent keymaps.
Inspired by spacemacs, we experiment with rebinding the =C-x= and =C-c= maps.
They are accessable by =SPC x= and =SPC c=, while the =C-x= map is also parent
of leader map. This way, all unambiguous key commands should be directly
accessable by =SPC=. Lets see how this works out.

#+BEGIN_SRC emacs-lisp
(defun evil-rc ()
  "evil local init/customization"
  (define-prefix-command 'leader-map)

  (define-key evil-normal-state-map " " leader-map)
  ;; yes, we really want to scroll up in evil mode
  (define-key evil-normal-state-map "\C-u" #'evil-scroll-up)

  (define-key leader-map "#" #'list-buffers)
  (define-key leader-map "l" #'global-linum-mode)

  (define-key leader-map "x" (key-binding "\C-x"))
  (set-keymap-parent leader-map (key-binding "\C-x"))
  (define-key leader-map "c" (key-binding "\C-c"))
  (def-evil-scroll-state))
#+END_SRC

**** experimental evil scroll mode

Example of defining an own evil mode. Motivated by the convenient navigation
mode ([[Convenient Navigation Mode]]) and a vi configuration mapping j to jzz, k
to kzz, this allows probably easier scrolling in evil.

#+BEGIN_SRC emacs-lisp
(defun def-evil-scroll-state ()
  (evil-define-state scroll "scroll-state"
    :tag " <S>"
    :message "-- SCROLL --"
    :suppress-keymap 't)
  (define-key evil-scroll-state-map "0" #'digit-argument)
  (define-key evil-scroll-state-map "1" #'digit-argument)
  (define-key evil-scroll-state-map "2" #'digit-argument)
  (define-key evil-scroll-state-map "3" #'digit-argument)
  (define-key evil-scroll-state-map "4" #'digit-argument)
  (define-key evil-scroll-state-map "5" #'digit-argument)
  (define-key evil-scroll-state-map "6" #'digit-argument)
  (define-key evil-scroll-state-map "7" #'digit-argument)
  (define-key evil-scroll-state-map "8" #'digit-argument)
  (define-key evil-scroll-state-map "9" #'digit-argument)
  (define-key evil-scroll-state-map (kbd "<return>") #'evil-ret)
  (define-key evil-scroll-state-map "j" (lambda nil
                                          (interactive)
                                          (call-interactively #'evil-next-line)
                                          (evil-scroll-line-to-center nil)))
  (define-key evil-scroll-state-map "k" (lambda nil
                                          (interactive)
                                          (call-interactively #'evil-previous-line)
                                          (evil-scroll-line-to-center nil)))
  (define-key evil-scroll-state-map (kbd "<escape>") 'evil-normal-state)
  (define-key evil-scroll-state-map "\C-\M-z" 'evil-emacs-state)
  (define-key leader-map "s" 'evil-scroll-state))
#+END_SRC

**** Evil Emacs config

When using evil-mode, we set ~evil-exit-emacs-state~ to =C-M-z=, as I'm used to
~suspend-frame~. Additionally, always enter evil mode in emacs state (see custom). This
way, without getting in the way it is always only a key press away.

#+BEGIN_SRC emacs-lisp
(defun change-evil-emacs-state (arg)
  "when ARG is true, set all live buffers to exit emacs-state. When nil, set
all buffers to emacs-state."
  (interactive "P")
  (setq evil-default-state (if arg 'normal 'emacs))
  (dolist (b (buffer-list))
    (with-current-buffer b
      (if arg
          (evil-exit-emacs-state)
        (evil-emacs-state)))))

(defun enter-evil ()
  "enter evil. That is, switch all buffers to normal mode and set default mode to normal."
  (interactive)
  (change-evil-emacs-state 't))

(defun exit-evil ()
  "exit evil. That is, switch all buffers to emacs mode and set default mode to emacs."
  (interactive)
  (change-evil-emacs-state nil))

(define-key evil-emacs-state-map "\C-z" nil)
(define-key evil-emacs-state-map "\C-\M-z" #'enter-evil)
(define-key evil-normal-state-map "\C-\M-z" #'exit-evil)
(advice-add #'evil-exit-emacs-state
            :before
            (lambda (&optional arg msg)
              (message "entering EVIL")
              (evil-rc)))
#+END_SRC

Now, after Initializing evil, we may probably also activate it in all buffers.

#+BEGIN_SRC emacs-lisp
(evil-mode)
(evil-rc)
#+END_SRC

*** Etags

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-ct" 'tag-complete-symbol)
(global-set-key "\C-cs" 'tags-search)
(global-set-key "\C-cr" 'tags-query-replace)
(defun my-generate-etags ()
  (interactive)
  (let* ((dir (read-string "project: "))
	 (cctarget (concat "../" dir "/*.cc"))
	 (hhtarget (concat "../" dir "/*.hh"))
	 (ctarget (concat "../" dir "/*.c"))
	 (htarget (concat "../" dir "/*.h")))
    (shell-command (concat "etags -a " cctarget " " hhtarget " " ctarget " " htarget " >/dev/null") nil)
    )
  )
(global-set-key "\C-ci" 'my-generate-etags)
#+END_SRC

*** C++ mode customizations, in use for aeons now

#+BEGIN_SRC emacs-lisp
;;(defun my-c++-hook () 
;;  (outline-minor-mode)
;;  (make-local-variable 'outline-regexp)
;;  (setq outline-regexp "[ \t]*// -+ "))
;;(add-hook 'c++-mode-hook 'my-c++-hook)
(add-hook 'c-mode-common-hook
          (lambda ()
            (c-toggle-auto-hungry-state 1)
            (c-set-style "Stroustrup")
	    (setq c-basic-offset 2)
            (setq c-hanging-braces-alist '((brace-list-open)
                                           (brace-list-close after)
                                           (defun-open after)
                                           (class-open after)
                                           (inline-open after)
                                           (substatement-open after)))))
;; (autoload 'c-mode "cc-mode" "C Editing Mode" t)
;; re-check
(setq auto-mode-alist
      (append '(("\\.C$"  . c++-mode)
                ("\\.cc$" . c++-mode)
                ("\\.m$" . objc-mode)
                ("\\.c$"  . c-mode)   ; to edit C code
                ("\\.h$"  . c-mode)   ; to edit C code
                ) auto-mode-alist))
#+END_SRC

*** compilation mode

#+BEGIN_SRC emacs-lisp
;; (global-set-key "\C-cc" 'compile)
;; (global-set-key "\C-cn" 'next-error)  ;;  this is now M-g M-n
;; (global-set-key "\C-cl" 'goto-line)
#+END_SRC

*** Auto-fill-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'fundamental-mode-hook
          (lambda () (auto-fill-mode 1)))
(add-hook 'text-mode-hook
          (lambda () (auto-fill-mode 1)))
(add-hook 'org-mode-hook
          (lambda () (auto-fill-mode 1)))
#+END_SRC

*** python mode

We use hippie-expand mapped to =M-/=

#+BEGIN_SRC emacs-lisp
(global-set-key [remap dabbrev-expand] #'hippie-expand)
#+END_SRC

We want to use flycheck in python.

#+BEGIN_SRC emacs-lisp
;; (require 'flycheck) ; not yet installed
#+END_SRC

~elpy-mode~ defines a bunch of useful support functions for navigating and
indenting in python buffers. Notably =C-c C-d= documentation for item under
point, =M-.= jump to definition of item under cursor, =M-*= pop back to where
=M-.= was last invoked, =C-c C-o= show all python definitions of current
buffer in occur view, =C-c C-z= switch to python shell.
For this, set ~python-shell-interpreter~ to path of buildout powerscript exe and
~python-shell-interpreter-args~ to "" (see custom).
Also worth to remember the company backend completion on =C-M-i=.

Note: ~elpy-enable~ adds to ~python-mode-hook~ only on first call. So if you
re-evaluate ~custom.el~, remember to afterwards ~(setq elpy-enabled-p nil)~
and ~(elpy-enable)~.

Because of this, provision of a function to reenable it after reloading
~custom.el~ has been proven to be handy. We enable elpy in ~init.el~ after loading
~custom.el~.

#+BEGIN_SRC emacs-lisp
;; (elpy-enable)  not yet installed

(defun elpy-reenable ()
  "make sure elpy is put into `python-mode-hook'."
  (interactive))
  ;; (setq elpy-enabled-p nil)  not yet installed
  ;; (elpy-enable))
#+END_SRC

To navigate using more convenient keys, we put the block navigation moves
(block in, block out, within block up and down) to =f=, =b=, =p= and =n=
combined with =C-M=. Other useful functions already on convenient keys are
=S-RET= open and indent line below, =C-S-RET= open and indent line above.
Also the python indentation functions (=C-c <= and =C-c >=) are remapped to
elpy. The =M-i= and =M-I= bindings first have to prove themselves.

#+BEGIN_SRC emacs-lisp
;; (define-key elpy-mode-map "\C-\M-p" #'elpy-nav-backward-block) ; not yet installed
;; (define-key elpy-mode-map "\C-\M-n" #'elpy-nav-forward-block)
;; (define-key elpy-mode-map "\C-\M-f" #'elpy-nav-forward-indent)
;; (define-key elpy-mode-map "\C-\M-b" #'elpy-nav-backward-indent)
;; (define-key elpy-mode-map "\M-i" #'elpy-nav-indent-shift-right)
;; (define-key elpy-mode-map "\M-I" #'elpy-nav-indent-shift-left)
;; (define-key elpy-mode-map [remap python-indent-shift-right] #'elpy-nav-indent-shift-right)
;; (define-key elpy-mode-map [remap python-indent-shift-left] #'elpy-nav-indent-shift-left)
#+END_SRC

The visibility toggling is on completely brain damaged keys, so we put at
least the toggle at point function at =S-tab=, being as convenient as in org
mode.

#+BEGIN_SRC emacs-lisp
;; (w32-register-hot-key (kbd "<M-tab>")) ; example of hot key override, but not practical
; (define-key elpy-mode-map (kbd "<S-tab>") #'elpy-folding-toggle-at-point) ; not yet installed
#+END_SRC

Enable autopep8, but don't activate it on save. However, use =M-g M-n= and
=M-g M-p= for flycheck next and flycheck previous error, which also show pep8 errors.

#+BEGIN_SRC emacs-lisp
; (require 'py-autopep8) ; not yet installed
;;(add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
;; (define-key elpy-mode-map [remap previous-error] #'flycheck-previous-error) ; not yet installed
;; (define-key elpy-mode-map [remap next-error] #'flycheck-next-error)
#+END_SRC

elpy makes indentation levels visible columnwise, so we also highlight the
current line of point.
As this is not only for python, currently enabled only in customize.

#+BEGIN_SRC emacs-lisp
;; (global-hl-line-mode)
#+END_SRC

The untabify-function defined here is disabled. Instead, we use custom
variable ~indent-tabs-mode~. Nevertheless, this may serve as an example, so it
stays here. custom python mode hook also activates jedi, superword and indent
tools mode, which binds =C-c >= as hydra.

#+BEGIN_SRC emacs-lisp
;; (defun python-mode-untabify ()
;;     (save-excursion
;;       (goto-char (point-min))
;;       (while (re-search-forward "[ \t]+$" nil t)
;;         (delete-region (match-beginning 0) (match-end 0)))
;;       (goto-char (point-min))
;;       (if (search-forward "\t" nil t)
;;           (untabify (1- (point)) (point-max))))
;;     nil)

;;(add-hook 'python-mode-hook
;;            '(lambda ()
;;               (make-local-variable 'write-contents-hooks)
;;               (add-hook 'write-contents-hooks 'python-mode-untabify)))
#+END_SRC

*** realgud debugging

We want to use middle mouse button on a variable to show the containing value.
On mac, this works only good in combination with some modifier, so we use
/super/ here.

#+BEGIN_SRC emacs-lisp
(global-set-key [(s-mouse-2)] #'realgud:tooltip-eval)
#+END_SRC

*** React programming

Combine javascript and web-mode, supporting ~jsx~ templates within. This is
probably outdated and should be re-evaluated. Is there already a real
react-mode? Otherwise, combine it with more up-to-date html-mode?

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.jsx\\'" . web-mode))
(add-hook 'web-mode-hook 'js2-minor-mode)
#+END_SRC

*** XML-mode 

**** hiding of subtrees

Here we use ~hs-mode~, enabling tag view toggling and tag level hiding. Also
~S-mouse-2~ can be used to toggle tag views.

#+BEGIN_SRC emacs-lisp
(setq sgml-quick-keys t)
(require 'hideshow)
(require 'sgml-mode)
(require 'nxml-mode)

(add-to-list 'hs-special-modes-alist
             '(nxml-mode
               "<!--\\|<[^/>]*[^/]>"
               "-->\\|</[^/>]*[^/]>"

               "<!--"
               sgml-skip-tag-forward
               nil))

(add-hook 'nxml-mode-hook #'hs-minor-mode)

(define-key nxml-mode-map (kbd "C-c C-h") #'hs-toggle-hiding)
(define-key nxml-mode-map (kbd "C-c C-l") #'hs-hide-level)
#+END_SRC

**** tagedit-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'nxml-mode-hook #'sgml-electric-tag-pair-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; (eval-after-load "sgml-mode"  not yet installed
;;   '(progn
;;      (require 'tagedit)
;;      (add-hook 'html-mode-hook (lambda () (tagedit-mode 1)))
;;      (add-hook 'nxml-mode-hook (lambda () (tagedit-mode 1)))))

;; (define-key tagedit-mode-map (kbd "C-c )") #'tagedit-forward-slurp-tag)
;; (define-key tagedit-mode-map (kbd "C-c }") #'tagedit-forward-barf-tag)
;; (define-key tagedit-mode-map (kbd "C-c s") #'tagedit-raise-tag)
;; (define-key tagedit-mode-map (kbd "C-M-k") #'tagedit-kill)
;; (define-key tagedit-mode-map (kbd "C-c a") #'tagedit-kill-attribute)
#+END_SRC

*** smartparens mode

In emacs lisp, we want slurp and barf support via smartparens. As the default
conflicts with my habits, we define our own mapping here.
Also use our delimiter for parens.
Plan is to use most of this with /Control/ and /Meta/ combination. Then splice
is ="=, unsplice is ~'~. ~(~ and ~)~ slurp in corresponding direction, ~{~ and
~}~ slurp.

#+BEGIN_SRC emacs-lisp
(require 'smartparens-config)
(sp--populate-keymap
 (let ((my-sp-bindings '(("C-M-f" . sp-forward-sexp) ;; navigation
                         ("C-M-b" . sp-backward-sexp)
                         ("C-M-u" . sp-backward-up-sexp)
                         ("C-M-d" . sp-down-sexp)
                         ("C-M-p" . sp-backward-parallel-sexp)
                         ("C-M-n" . sp-forward-parallel-sexp)
                         ("C-M-k" . sp-kill-sexp)
                         ("C-M-w" . sp-copy-sexp)
                         ("M-F" . sp-forward-symbol)
                         ("M-B" . sp-backward-symbol)
                         ("C-M-SPC" . sp-mark-sexp)
                         ("C-c s" . sp-splice-sexp) ;; depth-changing commands
                         ("C-M-\"" . sp-splice-sexp) ;; depth-changing commands
                         ("C-c S" . (lambda (point mark pre) (interactive "r\nP") (my-delimit-region pre ?\()))
                         ("C-M-'" . (lambda (point mark pre) (interactive "r\nP") (my-delimit-region pre ?\()))
                         ("C-c b" . sp-splice-sexp-killing-backward)
                         ("C-c f" . sp-splice-sexp-killing-forward)
                         ("C-c k" . sp-splice-sexp-killing-around)
                         ("C-c )" . sp-forward-slurp-sexp) ;; barf/slurp
                         ("C-M-)" . sp-forward-slurp-sexp) ;; barf/slurp
                         ("C-c }" . sp-forward-barf-sexp)
                         ("C-M-}" . sp-forward-barf-sexp)
                         ("C-c (" . sp-backward-slurp-sexp)
                         ("C-M-(" . sp-backward-slurp-sexp)
                         ("C-c {" . sp-backward-barf-sexp)
                         ("C-M-{" . sp-backward-barf-sexp)
                         ("C-c C-s" . sp-split-sexp)
                         ("C-c C-]" . sp-select-next-thing-exchange)
                         ("C-c ]" . sp-select-next-thing)
                         )))
   my-sp-bindings))
(add-hook 'emacs-lisp-mode-hook #'smartparens-mode)
#+END_SRC

*** markdown mode

#+BEGIN_SRC emacs-lisp
(autoload 'markdown-mode "markdown-mode"
  "Major mode for editing Markdown files" t)
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
(setq markdown-command "/Users/jko/Programming/node/node_modules/.bin/md2html")
#+END_SRC

*** yaml mode

Have RET indent like in python mode:

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode))
(add-hook 'yaml-mode-hook
          (lambda () (indent-tools-minor-mode))
          (lambda ()
            (define-key yaml-mode-map "\C-m" 'newline-and-indent)))
#+END_SRC

*** calendar/diary

#+BEGIN_SRC emacs-lisp
(setq view-diary-entries-initially t)
(setq view-calendar-holidays-initially t)
(setq mark-diary-entries-in-calendar t)
(setq mark-holidays-in-calendar t)
#+END_SRC

*** POV-Ray

#+BEGIN_SRC emacs-lisp
(setq load-path (cons "~/.emacs.d/lisp" load-path))
(autoload 'pov-mode "pov-mode.el" "PoVray scene file mode" t)
(setq auto-mode-alist
      (append '(("\\.pov$" . pov-mode)
		("\\.inc$" . pov-mode)
		) auto-mode-alist))
(setq pov-indent-level '2)
#+END_SRC

*** MIX (GNU MDK)

#+BEGIN_SRC emacs-lisp
(setq load-path (cons "/opt/local/share/mdk" load-path))
(autoload 'mixal-mode "mixal-mode" t)
(add-to-list 'auto-mode-alist '("\\.mixal\\'" . mixal-mode))
(autoload 'mixvm "mixvm" "mixvm/gud interaction" t)
#+END_SRC

** Disabled commands

#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
(put 'narrow-to-page 'disabled nil)
(put 'set-goal-column 'disabled nil)
;; (put 'eval-expression 'disabled nil)  ;; not longer needed
#+END_SRC

** Todo
*** TODO split custom.el into site specific customization and global custom selection to be merged/distributed
    - move mergeable options into init-babel.org?
*** TODO read about tramp plugins
*** TODO macro for command composition
    - compose key 1 and key 2
    - assign function name
    - where-is-internal - find key bindings for function
    - key-binding - find function for key binding
*** DONE complete mouse/trackpad handling/switching
*** DONE make window resize steps customizable, add center function
*** DONE display-buffer
**** DONE option close frame on quit instead of iconify
     - frame-auto-hide-function to delete
**** DONE build a function scaling selected window to fit buffer, but use max arg fract of frame
     - fit-window-to-buffer-max-half-frame
**** DONE how to make window dedicated? that is not 'dedicated' to a buffer, but not selected as other window
     - probably mitigated by not using display-buffer-use-some-window
**** DONE continue experiments with-current-buffer
**** DONE read display-buffer
**** DONE check dired buffer handling
     - experiment with logging display-buffer function
*** DONE find out about alist handling
*** DONE finetune nth-window and other window handling
    - s f. other-window-for-scrolling and v. other-window-scroll-buffer
    - select other window:
      - probably tag different windows with dedication tags (main work
        window, dired window, info/help window)
      - advice display-buffer functions not to use these
    - or define own actions
    - first see display-buffer docs
*** DONE complete keyboard switching
*** DONE cleanup misc, move to mode specific sections
*** DONE env-mode: use make-composed-keymap, set-keymap-parent
    this way, each action can define an own keymap indefinitely existing and
    just adding/removing it on enter/exit. Advantage is, rebind commands
    should also be effective on these existing keymaps.
    - also: call first toggle-my-environment on mode init. So if envs are
      defined, we are always in one of the valid states.
*** DONE think about movement/search placing point on beginning of adjacent object
    done at least for searching
