#+TITLE: Jörgs Emacs init
* Emacs Configuration
** Lisp functions
*** Initialization

We want to set each frame to reasonable color defaults by defining an
appropriate hook.

#+BEGIN_SRC emacs-lisp
(defgroup my-cust nil "my customizations")
(defcustom my-frame-transparency 100
  "transparency used for all display frames."
  :type '(integer)
  :group 'my-cust
  :set (lambda (symb val)
         (setq my-frame-transparency val)
         (dolist (frame (frames-on-display-list))
           (set-frame-parameter frame 'alpha `(,val . ,val)))))
(add-hook 'after-make-frame-functions
	  (lambda (frame)
	    (set-frame-parameter frame 'alpha (cons my-frame-transparency my-frame-transparency))
	    (with-selected-frame frame
	      (set-background-color "Black")
	      (set-foreground-color "Green")
	      )))
#+END_SRC

*** Handling of other window

First of all, a topic of long and outstanding troubles has been the question
of seemingly eratically automatic selection of the other window. As it seems, this is
actually a quite deterministic operation. Its frontend is ~pop-to-buffer~, the
implementation and documentation is in ~display-buffer~. There, a range of
~display-buffer-functions~ can be selected and combined at will, generating
this behaviour. Now, often you may want to craft a window configuration into
your frame, so you dont want any of this to be misused. 

A first mitigation may ne to sensibly change the ~display-buffer-fallback-action~,
overriding it in ~display-buffer-base-action~. Here we just replace the
~display-buffer-use-some-window~ function which probably is the source of those
erratic behaviour. Our replacement is ~display-buffer-below-selected~, which on
first view seems to be not such a bad selection for frames using a large screen space.

But we also need to make sure windows are not splitted if too small. We also
activate some further tweaks which are declared in the following sections.

#+BEGIN_SRC emacs-lisp
(custom-set-variables
 '(display-buffer-alist
   '((dired-to-other-window make-buffer-window-origin)
     (dired-from-other-window
      (display-buffer-maybe-in-orig))
     ("\\*Occur\\*" make-buffer-window-origin)
     ((lambda
        (buffer alist)
        (match-current-buffer "\\\\*Occur\\\\*"))
      display-buffer-in-orig)
     ("\\*Help\\*\\|\\*Apropos\\*"
      (display-buffer-as-scroll-buffer display-buffer-dedicated-window display-buffer-reuse-help display-buffer-at-bottom)
      (window-height . fit-window-to-buffer-max-half-frame))))
 '(display-buffer-base-action
   '((display-buffer-maybe-as-scroll-buffer display-buffer-dedicated-window display-buffer--maybe-same-window display-buffer-reuse-window display-buffer--maybe-pop-up-frame-or-window display-buffer-in-previous-window display-buffer-below-selected display-buffer-pop-up-frame)))
 '(window-min-height 8)
 '(window-min-width 40))
#+END_SRC

Finally we add a function to recursively edit with original behaviour.

#+BEGIN_SRC emacs-lisp
(defun edit-with-fallback-display ()
  "reset `display-buffer-base-action' and edit recursively, to
  have the original buffer sharing behaviour."
  (interactive)
  (let ((display-buffer-base-action nil))
    (recursive-edit)))
#+END_SRC

**** Help and Apropos buffers

We want to put those buffers into dedicated windows or into windows at bottom,
where they are unobtrusive and can stay as long as we want.
If such a window already exists, we want to reuse it, specifying a
corresponding action.

#+BEGIN_SRC emacs-lisp
(defun window-apply-height-fnc (window alist)
  "rudimentary alist parser just accepting a height fnc for now.."
  (let ((height (cdr (assq 'window-height alist))))
    (if (functionp height)
        (ignore-errors (funcall height window)))
    window))

(defun window-update-buffer (buffer window type alist)
  "display buffer in window, recording type then apply height"
  (if (window--display-buffer buffer window type alist)
      (window-apply-height-fnc window alist)))

(defun display-buffer-reuse-help (buffer alist)
  "If a *Help* or *Apropos* window is live, try to reuse that."
  (let ((wnd (car (remove-if-not
                   (lambda (w)
                     (string-match "\\*Help\\*\\|\\*Apropos\\*"
                                   (buffer-name (window-buffer w))))
                   (window-list)))))
    (if (and wnd (window-live-p wnd))
        (window-update-buffer buffer wnd 'reuse alist))))
#+END_SRC

Now we define a buffer specific ~window-height~ action attribute only for
help and apropos buffers, specifying our custom function
~fit-window-to-buffer-max-half-frame~, which may need more tweaking to use less
than half frame height or also to use height of original window before split.

#+BEGIN_SRC emacs-lisp
(defun fit-window-to-buffer-max-half-frame (&optional window)
  "fit window to buffer size, but use max half of current frame height."
  (interactive)
  (let ((wnd (or window (selected-window)))
        (max-height (/ (frame-height) 2)))
    (fit-window-to-buffer window max-height)))
#+END_SRC

**** Dired and other file navigation buffers

Now, we define a special handling for ~dired~ buffers. We leave it alone if
used in the same window. But when used in other window, it should memorize its
origin window and put view buffers sent to subsequent other windows there.

#+BEGIN_SRC emacs-lisp
(defun set-orig-window (window)
  "mark the given window as origin of operation, removing the mark from all
others of frame. This way, a dired buffer in other window can push its
  subsequent other window view buffers into the origin window."
  (walk-windows (lambda (w)
                  (set-window-parameter w 'orig-window nil)))
  (set-window-parameter window 'orig-window 't))

(defun make-buffer-window-origin (buffer alist)
  "use with a regex or matcher to memorize origin window. Then use
`display-buffer-in-orig' with same regex to push buffers to origin."
  (set-orig-window (selected-window))
  nil)

(defun display-buffer-in-orig (buffer alist)
  "if a live orig window is defined, unconditionally use that to
display the buffer."
  (let ((my-window
         (car (remove-if-not (lambda (w)
                               (eq 't (window-parameter w 'orig-window)))
                             (window-list)))))
    (if (and my-window (window-live-p my-window))
        (window-update-buffer buffer my-window 'reuse alist))))

(defun display-buffer-maybe-in-orig (buffer alist)
  "if action attribute inhibit-same-window is given and a live orig window is
defined, use that to display the buffer."
  (if (cdr (assq 'inhibit-same-window alist))
      (display-buffer-in-orig buffer alist)))
#+END_SRC

Helper function ~dired-p~ checks if a buffer has some ~dired-mode~. The
following two predicate functions check if the originating or the new buffer
is a dired buffer.

#+BEGIN_SRC emacs-lisp
(defun dired-p (buffer)
  "is buffer's major mode a dired mode?"
  (let ((mode (with-current-buffer buffer major-mode)))
    (string-match "dired-.*mode" (symbol-name mode))))

(defun dired-to-other-window (buffer alist)
  "match if new buffer is a dired buffer."
  (dired-p buffer))

(defun dired-from-other-window (buffer alist)
  "match if current buffer is a dired buffer."
  (dired-p (current-buffer)))
#+END_SRC

A generalized matcher function, matching the current buffer.
Different applications use different strategies to display their buffers, so
you may need to use the ~display-buffer~-variants with or withour ~maybe~. See
customization at the beginning for an example addressing occur.

#+BEGIN_SRC emacs-lisp
(defun match-current-buffer (regex)
  "match if regex matches current buffer."
  (string-match regex (buffer-name (current-buffer))))
#+END_SRC

**** Dedicated window

Use this to define a dedicated 'other' window. Optional arg allows to limit
the dedication to the next ~n~ buffer pushs. So prefix =C-1= makes a one time
dedication, =C-0= removes a dedication.

#+BEGIN_SRC emacs-lisp
(defvar dedicated-other-window nil)
(defvar dedication-count)

(defun dedicate-window (arg)
  "Dedicate the currently selected window as 'other' window. When
called with a =C-0= prefix arg, releases the previously set
window and reverts to the default window selection behaviour. Default is a
one-time dedication, use =C-u= for unlimited."
  (interactive "p")
  (setq dedicated-other-window
        (if (eq arg 0)
            nil
          (selected-window)))
  (setq dedication-count
        (if (eq 4 arg) nil arg))
  (if dedicated-other-window
      (message "window dedicated")
    (message "dedication removed")))

(defun display-buffer-dedicated-window (buffer alist)
  "Display pop-up-buffer in the dedicated other window, if one is
selected. If none is selected, revert to the default behaviour."
  (if (and dedicated-other-window
           (window-live-p dedicated-other-window))
      (prog1
          (window-update-buffer buffer dedicated-other-window 'reuse alist)
        (if (and dedication-count (> dedication-count 0))
            (setq dedication-count (- dedication-count 1)))
        (if (eq 0 dedication-count)
            (setq dedicated-other-window nil)))))
#+END_SRC

**** Other window applications

This sorted out, I'm adding some useful functions for handling the other
window. This can be handy after calling or navigating within help texts for
example.

First, some functions recording a buffer to be shown in another window. This
one should be remote controllable as long as it is visible. When removed and
no new buffer pushed to another window, we will fall back to the remote
controlling behaviour selecting the next window.

#+BEGIN_SRC emacs-lisp
(defun display-buffer-as-scroll-buffer (buffer alist)
  "This action actually doesn't display a buffer, but records it
as `other-window-scroll-buffer'. It always returns nil so it can
be placed with highest priority."
  (setq other-window-scroll-buffer buffer)
  nil)

(defun display-buffer-maybe-as-scroll-buffer (buffer alist)
  "This action actually doesn't display a buffer, but records it as
`other-window-scroll-buffer', if the inhibit-same-window attribute
is given. It always returns nil so it can be placed with highest priority."
  (if (cdr (assq 'inhibit-same-window alist))
      (display-buffer-as-scroll-buffer buffer alist)))

(defun scroll-buffer-window ()
  "find window of `other-window-scroll-buffer', if live, or reset
other-window-scroll-buffer to nil, letting the other-window
functions fall back to default."
  (let ((scroll-window (get-buffer-window other-window-scroll-buffer)))
    (if (and (buffer-live-p other-window-scroll-buffer)
             (window-live-p scroll-window))
        scroll-window
      (setq other-window-scroll-buffer nil))))

(defun my-scroll-other-window ()
  "just like `scroll-other-window', but don't pop up the window
if not live."
  (interactive)
  (scroll-buffer-window)
  (call-interactively #'scroll-other-window))

(defun my-scroll-other-window-down ()
  "just like `scroll-other-window-down', but don't pop up the window
if not live."
  (interactive)
  (scroll-buffer-window)
  (call-interactively #'scroll-other-window-down))
#+END_SRC

A macro defining remote controlling functions. Default is to address the next window,
but you can specify one with a prefix arg.

#+BEGIN_SRC emacs-lisp
(defmacro nth-window (fname docstring &rest body)
  "Defines an interactive function performing the forms in BODY
 in other window or window specified by prefix arg. Uses FNAME as
 function name and describes it with DOCSTRING."
  `(defun ,fname (arg)
     ,docstring
     (interactive "P")
     (save-selected-window
       (select-other-window arg)
       ,@body)))
#+END_SRC

..and a function coding the logic to find the other window.

#+BEGIN_SRC emacs-lisp
(defun select-other-window (arg)
  "selects and returns the other window or window specified by prefix arg."
  (interactive "P")
  (let ((scroll-window (scroll-buffer-window)))
    (if (and (eq arg nil)
             other-window-scroll-buffer
             scroll-window)
        (select-window scroll-window)
      (other-window (or arg 1))))
  (selected-window))
#+END_SRC

The same for frames might also come in handy.

#+BEGIN_SRC emacs-lisp
(defmacro nth-frame (fname docstring &rest body)
  "Defines an interactive function performing the forms in BODY
 in other frame or frame specified by prefix arg. Uses FNAME as
 function name and describes it with DOCSTRING."
  `(defun ,fname (arg)
     ,docstring
     (interactive "p")
     (let ((current (selected-frame)))
       (other-frame arg)
       ,@body
       (select-frame-set-input-focus current))))
#+END_SRC

And now some other-window-functions. The last one is generic: it allows to
jump to a window, work there and afterwards return. It also allows nested
jumps and returning with =C-M-c= or =C-]=.

#+BEGIN_SRC emacs-lisp
(nth-window go-back-other-window
  "Go back to previous help topic in other window."
  (help-go-back))

(nth-window quit-restore-other-window
  "Quit other window and deal with its buffer, possibly restoring
      the buffer previously displayed in other window."
  (quit-restore-window (selected-window)))

(nth-window shrink-other-window-if-larger-than-buffer
  "Shrink height of other window if its buffer doesn't need so many lines."
  (shrink-window-if-larger-than-buffer))

(nth-window beginning-of-other-window
  "Like `beginning-of-buffer-other-window', but use prefix arg to select window."
  (beginning-of-buffer))

(nth-window end-of-other-window
  "Like `end-of-buffer-other-window', but use prefix arg to select window."
  (end-of-buffer))

(nth-window edit-other-window
  "recursively edit in other buffer, allowing to return later."
  (recursive-edit))
#+END_SRC

*** Convenient error stepping

Often I want to quickly navigate through a list of error messages or
occurencies, jumping to the places the errors are indicating. There are
different ways to archieve this. First of all, with =C-x C-f= you can activate
~error-follow-minor-mode~, allowing to move the mark through the error buffer,
letting the referenced source buffers follow you. But if you want to have the
source buffer active, you would need to jump to the error buffer for each next
step. As a remedy, the following functions are introduced. While they follow
the previous scheme adding remote control functions for the other window, they
also show a cool feature of setting a temporary keymap in place, allowing
further navigation steps by using shortcuts. This way, the long key sequence
of addressing the other window (=C-x 4=) and starting the goto sequence
(=M-g=) needs to be casted only as an initiation. Afterwards, it gets really
easy. This is quite convenient in the most different applications.

#+BEGIN_SRC emacs-lisp
(require 'cl)

(defun error-step ()
  (macrolet ((step-msg ()
		       '(message "Use n,p,< to navigate further")))
    (step-msg)
    (set-transient-map
     (let ((map (make-sparse-keymap)))
       (dolist (modk '(() (meta)))
	 (define-key map (vector (append modk '(?n)))
	   (lambda () (interactive) (next-error) (step-msg)))
	 (define-key map (vector (append modk '(?<)))
	   (lambda () (interactive) (first-error) (step-msg)))
	 (define-key map (vector (append modk '(?p)))
	   (lambda () (interactive) (previous-error) (step-msg))))
       map) 't)))

(defun next-error-other-window (&optional arg)
  "Visit next error message displayed in other window's buffer. With prefix arg, jump to nth error."
  (interactive "P")
  (with-current-buffer (window-buffer (next-window))
    (next-error arg)
    (error-step)))

(defun previous-error-other-window (&optional arg)
  "Visit previous error message displayed in other window's buffer. With prefix arg, jump to nth error."
  (interactive "P")
  (with-current-buffer (window-buffer (next-window))
    (previous-error arg)
    (error-step)))
#+END_SRC

*** Convenient Navigation Mode

This is an experimental feature in the spirit of previous means of other
window handling, allowing for activation of a temporary navigation mode. Using
this, you can conveniently navigate, scroll, set marks and jump to previous
mark positions. Features include navigating up and down of the point,
scrolling up and down, jumping to begin and end of buffer, pagewise up and
down. Most of these can be combined with a numeric argument. The mode is
cancelled by using any other key.

#+BEGIN_SRC emacs-lisp
(defun navigate-buffer (&optional window)
  "Enter a temporary buffer navigation mode. WINDOW specifies an optional window pointer,
allowing to specify a remote window to be controlled."
  (lexical-let ((arg-acc 0) (arg-neg nil) (consumed nil)
		(window (or window (selected-window))))
    (labels ((set-consumed () (setq consumed 't))
	     (acc-reset ()
			(if consumed
			    (setq arg-acc 0 arg-neg nil consumed nil)))
	     (get-arg-acc (&optional default)
			  (let ((res (if (> arg-acc 0)
					 (* arg-acc (if arg-neg -1 1))
				       default)))
			    res))
	     (acc-status () (message "navigate ([-,0-9] n,p,N,P,v,V,<,>,[,],l, ) %c %d"
				     (if arg-neg arg-neg '? ) arg-acc))
	     (arg-negate ()
			 (setq arg-neg (if arg-neg nil '?-))
			 (acc-status))
	     (arg-accumulate (num)
			     (setq arg-acc (+ (* arg-acc 10) num))
			     (acc-status)))
      (macrolet ((with-window (&rest body)
			      `(lambda () (interactive)
				 (set-consumed)
				 (with-selected-window window
				   ,@body
				   (acc-status)))))
	(acc-status)
	(set-transient-map
	 (let ((map (make-sparse-keymap)))
	   (define-key map [?-] (lambda () (interactive) (acc-reset) (arg-negate)))
	   (dolist (num '(?0 ?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9))
	     (define-key map (vector num)
	       (lambda ()
		 (interactive)
		 (acc-reset)
		 (let* ((ev last-command-event)
			(base (event-basic-type ev)))
		   (arg-accumulate (- base 48))))))
	   (define-key map " " (with-window
				(if (eq arg-acc 0)
				    (progn (set-mark-command nil)(deactivate-mark))
				  (set-mark-command (get-arg-acc)))))
	   (define-key map "n" (with-window (next-line (get-arg-acc 1))))
	   (define-key map "p" (with-window (previous-line (get-arg-acc 1))))
	   (define-key map "/" (with-window (isearch-forward))) ;not documented
	   (define-key map "l" (with-window (recenter-top-bottom (get-arg-acc))))
	   (define-key map "r" (with-window (move-to-window-line-top-bottom (get-arg-acc))))
	   (define-key map "<" (with-window (beginning-of-buffer (get-arg-acc))))
	   (define-key map ">" (with-window (end-of-buffer (get-arg-acc))))
	   (define-key map "]" (with-window (forward-paragraph (get-arg-acc))))
	   (define-key map "[" (with-window (backward-paragraph (get-arg-acc))))
	   (define-key map "N" (with-window (scroll-up-line (get-arg-acc 1))))
	   (define-key map "P" (with-window (scroll-down-line (get-arg-acc 1))))
	   (define-key map "v" (with-window (scroll-up-command (get-arg-acc))))
	   (define-key map "V" (with-window (scroll-down-command (get-arg-acc))))
	 map) 't)))))

(nth-window navigate-other-window
  "Enter a temporary buffer navigation mode, allowing some window to be
controlled remotely. Default is the other window. Optional argument
selects the nth window. This allows moving around some window without
de-selecting the current window, enabling a very convenient means of
temporarily moving around. 

Keys are:
  -, 0-9: set an argument to following commands, which stays in effect until
          reset (e.g. by pressing 0)
  space: set a mark; with arg jump to mark
  n, p: move point to next/previous line
  l: recenter buffer to point
  r: move point to window center
  <, >: move point to beginning/end of buffer
  [, ]: move point forward/backward in paragraphs
  N, P: scroll up/down
  v, V: pagewise scroll up/down"
  (navigate-buffer))
#+END_SRC

*** Windows run commands

For Windows, we define a few shortcuts running command shells, using these as
a kind of ~ansi-term~ replacement.

#+BEGIN_SRC emacs-lisp
(defun run-cmdexe ()
  (interactive)
  (let ((shell-file-name "cmd.exe"))
    (shell "*cmd.exe*")))

(defun run-sdk ()
  (interactive)
  (let ((shell-file-name "c:\\sdk\\win32\\1.1\\scripts\\sdk-shell-vs90.bat"))
    (shell "*sdk*")))

(defun run-wsl ()
  (interactive)
  (let ((shell-file-name "c:\\Windows\\System32\\bash.exe"))
    (shell "*wsl*")))

(defun run-bash ()
  (interactive)
  (let ((shell-file-name "c:\\Program Files\\Git\\bin\\bash.exe"))
    (shell "*bash*")))
#+END_SRC

*** Frame and window size

Interactively resize windows.

#+BEGIN_SRC emacs-lisp
(defun resize-window ()
  "Resize current window interactively using continuous key presses.
Keys supported:

 - shrink window vertically
 + enlarge window vertically
 [ shrink window horizontally
 ] enlarge window horizontally
 0 balance all frames window sizes"
  (interactive)
  (macrolet ((msg ()
		  '(message "resize window (-,+,{,},0)"))
	     (lmb (fnc)
		  `(lambda () (interactive)
		     (msg)
		     ,fnc)))
    (msg)
    (set-transient-map
     (let ((tmap (make-sparse-keymap)))
       (define-key tmap "0" (lmb (balance-windows)))
       (define-key tmap "-" (lmb (shrink-window 1)))
       (define-key tmap "+" (lmb (enlarge-window 1)))
       (define-key tmap "=" (lmb (enlarge-window 1))) ; easy access on us keyboard
       (define-key tmap "^" (lmb (enlarge-window 1))) ; reuse entry key
       (define-key tmap "&" (lmb (enlarge-window 1))) ; german keyboard
       (define-key tmap "{" (lmb (shrink-window-horizontally 1)))
       (define-key tmap "Ü" (lmb (shrink-window-horizontally 1))) ; german keyboard, here "U
       (define-key tmap "}" (lmb (enlarge-window-horizontally 1)))
       (define-key tmap "*" (lmb (enlarge-window-horizontally 1))) ; german keyboard
       tmap) 't)))
#+END_SRC

This used to be a frame maximize function for Mac, which is not longer
needed here. Instead we build a configurable solution toggling through
normal, maximized and visually attractive. "Visually attractive" would
then be something like "leave a small configurable space outside the
frame and use the rest of screen". For this, we use a customizable
variable constructing a list of frame styling functions. The functions
receive an argument list of (FRAME MAX-LINES MAX-COLS).

#+BEGIN_SRC emacs-lisp
(defcustom my-frame-stylings nil
  "styling functions used when toggling display frame size."
  :type '(repeat function)
  :group 'my-cust)

(defun switch-frame ()
  "Set frame to reasonable position and size based on some heuristics.
  Alternatively, toggles size to maximized."
  (interactive)
  (let ((maximized (frame-parameter nil 'fullscreen))
        (confectioned (frame-parameter nil 'my-confectioned)))
    (cond
     ((eq confectioned 't)
      (let ((geom (frame-parameter nil 'my-geometry)))
        (set-frame-parameter nil 'my-confectioned nil)
        (set-frame-width nil (cadr geom))
        (set-frame-height nil (caddr geom))
        (set-frame-position nil (caar geom) (cdar geom))))
     ((eq maximized 'maximized)
      (let ((max-lines (frame-parameter nil 'height))
            (max-cols (frame-parameter nil 'width)))
	(set-frame-parameter nil 'fullscreen nil)
        (set-frame-parameter nil 'my-confectioned 't)
        (dolist (fnc my-frame-stylings)
                (funcall fnc (selected-frame) max-lines max-cols))))
     ((eq maximized nil)
      (set-frame-parameter nil 'my-geometry
                           (list (frame-position)
                                 (frame-width)
                                 (frame-height)))
      (set-frame-parameter nil 'fullscreen 'maximized)))))

(defun frame-width-below-threshold (frame lines cols)
  (set-frame-width frame (- split-width-threshold 1)))

(defun frame-height-dec (frame lines cols)
  (set-frame-height frame (- lines 1)))

(defun frame-to-left (frame lines cols)
  (set-frame-position frame 0
                      (cdr (frame-position frame))))

(defun frame-to-top (frame lines cols)
  (set-frame-position frame
                      (car (frame-position frame))
                      8))
#+END_SRC

Here we toggle fullscreen, removing all frame decorations and
transparency.

#+BEGIN_SRC emacs-lisp
(defun toggle-maximize-frame ()
  "Toggle fullscreen and switch off menu bar and scroll bar."
  (interactive)
  (labels ((set-scroll-bar (where) (customize-set-variable 'scroll-bar-mode where)))
    (let ((fullscreen (frame-parameter nil 'fullscreen)))
      (cond
       ((memq fullscreen '(fullscreen fullboth))
	(set-scroll-bar (frame-parameter nil 'scrollbar))
	(set-frame-parameter nil 'scrollbar nil)
        (apply (get 'my-frame-transparency 'custom-set) 'my-frame-transparency
               (frame-parameter nil 'my-transparency) nil)
        (set-frame-parameter nil 'my-transparency nil)
	(toggle-menu-bar-mode-from-frame 1)
        (toggle-frame-fullscreen))
       ((eq fullscreen nil)
	(set-frame-parameter nil 'scrollbar scroll-bar-mode)
	(menu-bar-no-scroll-bar)
	(set-frame-parameter nil 'my-transparency my-frame-transparency)
        (apply (get 'my-frame-transparency 'custom-set) 'my-frame-transparency 100 nil)
	(toggle-menu-bar-mode-from-frame 0)
        (toggle-frame-fullscreen))))))
#+END_SRC

*** electric delimiter

Often I want to put some text into delimiters after writing it, for example a
string or an argument list. So the reverse of a splicing operation is needed.
Here, you can define a region and delimit it using a character. In the special
case of the character being an opening type of brace, automatically selects
the corresponding closing brace. When called with prefix arg, the region is
newly indented after delimiting.

#+BEGIN_SRC emacs-lisp
(defun my-delimit-region (point mark pre bd)
  "Frame region with delimiters. If delim is an opening type of
brace, automatically use the corresponding closing delimiter,
otherwise use the same char for both sides. If called
interactively, take next key press as opening delimiter. If
called with prefix arg, the region is newly indented after
delimiting."
  (interactive "r\nP\nc")
  (let ((ed (case bd
              ((?\() ?\))
              ((?\[) ?\])
              ((?{) ?})
              ((?<) ?>)
              (t bd))))
    (save-excursion
      (goto-char mark)
      (insert ed))
    (save-excursion
      (goto-char point)
      (insert bd))
    (if pre (indent-region point mark))))
#+END_SRC

*** Push buffer to frame

Sometimes, auxiliary buffers to be displayed in the 'other' window are
eratically pushed into some well arranged window. While this can be configured
through action variables used by ~display-buffer~, this is a complex and
error-prone configuration. To mitigate, use this function to push it into its
own frame and revert the previously crafted window arrangement.

This also calls a little bit for some further 'remote control other frame'
functions..

#+BEGIN_SRC emacs-lisp
(defun push-buffer-to-frame ()
  "push current window buffer to own frame and revert current window to previous frame."
  (interactive)
  (let ((current (current-buffer))
        (selected (selected-window)))
    (if (display-buffer-other-frame current)
        (quit-restore-window selected))))
#+END_SRC

To make this work smoothly, we also change iconification of frames on close.

#+BEGIN_SRC emacs-lisp
(custom-set-variables
 '(frame-auto-hide-function #'delete-frame))
#+END_SRC

** Environment Minor Mode
We want to easily be able to switch between different environments. For
example, using a notebook in mobile or in docked mode may mean using mouse or
trackpad, apple or pc keyboard. This is implemented in a global minor mode,
binding a hot key as environment toggle. Each environment is designated by an
id character shown in the mode line and a list of actions. Each action has
enter and exit functions to setup and leave the corresponding action. This
way, actions can be defined in terms of (lambda) functions. Also an action can
be part of different environments.
After customizing the mode, use =C-c C-\= to toggle through environments.

#+BEGIN_SRC emacs-lisp
(defgroup my-environment nil "my environments")

(defcustom my-env-actions nil
  "list of actions. Each element has the form (symb enter-fnc
exit-fnc), where symb is a symbol used to address this definition, enter-fnc
and exit-fnc are functions to setup and leave the corresponding state."
  :type '(repeat (list symbol function function))
  :group 'my-environment)

(defcustom my-env-definitions nil
  "list of environments to toggle through. Each definition has the form (id
(list of symbols)), where id is a character shown in the mode
line describing the current environment. Then follows a list of
action symbols. Each of these actions is entered when
environment is toggled on and exited when another environment
is selected. If only one env is defined, toggles between this
only, so you should probably at least define a second env with
a default N id and no actions."
  :type '(repeat (list character (repeat symbol)))
  :group 'my-environment)

(defun my-env-init-keymap ()
  "setup a keymap for my-environment-mode, inserting the env toggle hot key."
  (define-prefix-command 'my-env-map)
  (let ((kmap (make-sparse-keymap)))
    (define-key kmap "\C-c" my-env-map)
    (define-key my-env-map "" #'toggle-my-environment)
    kmap))

(defun my-env-add-map (kmap)
  "Use this function in your enter action definitions to add sparse keymaps to the current environment."
  (pushnew kmap my-env-maps))

(defun my-env-remove-map (kmap)
  "Use this function in your exit action definitions to remove sparse keymaps from the current environment."
  (setq my-env-maps (remote-if (lambda (elem)
                                 (eq elem kmap))
                               my-env-maps)))

(define-minor-mode my-environment-mode
  "Minor mode supporting easy switching between different environments. For
example, using a notebook in mobile or in docked mode may mean using mouse or
trackpad, apple or pc keyboard.

\\{my-environment-mode-map}"
  nil
  " [N]"
  (my-env-init-keymap)
  :group 'my-environment
  :global 't
  :after-hook (toggle-my-environment))
#+END_SRC

You may add key definitions in enter action
functions with ~my-env-add-map~.
To remove them on exit, if you dont declare an exit function, as a convenience
use =my-env-reset-keymap=.

#+BEGIN_SRC emacs-lisp
(defun my-env-reset-keymap ()
  "If your enter function added to the minor mode or my-env keymaps, your exit
function should call this function to reset it."
  (setq my-env-maps nil))
#+END_SRC

*** Internals

#+BEGIN_SRC emacs-lisp
(defvar my-env-action nil) ; current env cell. car is the env, cdr the next cell..

(defvar my-env-maps nil) ; list of maps to combine into current env
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my-env-update-parent-map ()
  "creates a parent for the minor mode composing all current action maps."
  (set-keymap-parent my-environment-mode-map (make-composed-keymap my-env-maps)))

(defun my-env-enter-action (action)
  "calls the enter definition of given action if provided."
  (let ((aclist (remove-if-not (lambda (elem)
                                 (eq action (car elem)))
                               my-env-actions)))
    (if (and aclist (cadar aclist))
        (funcall (cadar aclist)))))

(defun my-env-exit-action (action)
  "calls the exit definition of given action if provided."
  (let ((aclist (remove-if-not (lambda (elem)
                                 (eq action (car elem)))
                               my-env-actions)))
    (if (and aclist (caddar aclist))
        (funcall (caddar aclist)))))

(defun toggle-my-environment ()
  "toggles activation of next environment. If only one env is defined, toggles
between this only, so you should probably at least define a second env with a
default N id and no actions."
  (interactive)
  (let ((current my-env-action)
        (next
         (if (not my-env-action)
             my-env-definitions
           (let ((next-first
                  (cdr my-env-action)))
             (if (not next-first)
                 my-env-definitions
               next-first)))))
    (if current
        (let ((env (car current)))
          (dolist (action (cadr env))
            (my-env-exit-action action))))
    (if next
        (let ((env (car next)))
          (dolist (action (cadr env))
            (my-env-enter-action action))
          (my-env-update-parent-map)
          (my-env-update-lighter (format " [%c]" (car env)))))
    (setq my-env-action next)))

(defun my-env-update-lighter (lighter)
  "update the lighter of minor mode to reflect the selected environment."
  (setcar
   (cdar (remove-if-not (lambda (elem)
                          (eq (car elem) 'my-environment-mode))
                        minor-mode-alist))
   lighter)
  (force-mode-line-update 't))
#+END_SRC

** Global key bindings
*** Generic

Some convenience keys for handling buffers and files. Use caution and check to
not shadow future functionality here.
We replace =C-x C-f= with ~find-file~, as the ~-at-point~ function is then
still reachable through =M-n=. The old mapping of =C-c C-f= to
~find-file-at-point~ is removed, as it is now overlayed by org.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x\C-b" #'bs-show)	;; this used to be electric-buffer-list
(global-set-key "\C-x\C-f" #'find-file)
(global-set-key [3 67108919] #'toggle-my-environment)  ;; make global to enable env switch on german kbd
#+END_SRC

And my delimiting function:

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cF" #'my-delimit-region)
#+END_SRC

*** Convenience for searching

Often you want to finish a search leaving the point on the first character of
the string found. This enables using isearch as a convenient tool for
positioning, selecting or killing to but not including a string. This is
enabled here on =C-return=.

#+BEGIN_SRC emacs-lisp
(define-key isearch-mode-map (kbd "<C-return>")
  (lambda () (interactive)
    (isearch-repeat (if isearch-forward
                        'backward
                      'forward))
    (isearch-exit)))
#+END_SRC

*** Scrolling

Convenience keys for buffer scrolling. Enables up/down also with /Meta/
modifier. Together with /Shift/ this enables scrolling. This way you can very
conveniently move the pointer and scroll by just adding/releasing the /Shift/
modifier.

#+BEGIN_SRC emacs-lisp
(global-set-key "\M-p" #'previous-line)
(global-set-key "\M-n" #'next-line)
(global-set-key "\M-P" #'scroll-down-line)
(global-set-key "\M-N" #'scroll-up-line)
(global-set-key [end] #'move-end-of-line)
(global-set-key [home] #'move-beginning-of-line)
#+END_SRC

*** Ace zapping

Ace enables some more vi-style jumping and zapping (see =M-z= for the basic
~zap-to-char~ function).

#+BEGIN_SRC emacs-lisp
(global-set-key "\M-J" #'ace-jump-char-mode)
;;;(global-set-key "\C-x\C-j" #'ace-jump-mode-pop-mark) ;; this is dired-jump
(global-set-key "\C-x\C-z" #'zzz-up-to-char)
#+END_SRC

*** Mouse handling

Mouse keys: remember basic mouse button handling in emacs: left - set pointer,
double left - select word, triple left - select line, drag - select, drag
after double - select words, right - define region and save to kill ring,
right after double click - define region up to next word, double right - kill
to kill ring, middle - yank to click position.

Additionally, you can double click on delimiters like parens or quotes to
select the delimited text. Finally, we activated the drag and drop feature.

~mouse-wheel-mode~ also enables mouse wheel scrolling. With /Meta/,
enables scroll turbo; with /shift/, scale text (seems to work only on
trackpad, as it is mapped to =S-wheel-left= / =right=).

To revert yanks when hand on mouse, we place ~undo~ on =M-mouse-2=. Probably
no more customizations to be done. Especially when using the trackpad, hands
are already near keyboard.

#+BEGIN_SRC emacs-lisp
(defun mouse-undo ()
  "undo with mouse button."
  (let ((kmap (make-sparse-keymap)))
    (define-key kmap (kbd "<M-mouse-2>") #'undo)
    (my-env-add-map kmap)))
#+END_SRC

When using a mouse wheel, we also want to use the text size zooming feature which
in wheel-mode apparently works only with native trackpad.

#+BEGIN_SRC emacs-lisp
(defun my-wheel-zoom ()
  (let ((kmap (make-sparse-keymap)))
    (define-key kmap (kbd "<S-wheel-down>") #'text-scale-increase)
    (define-key kmap (kbd "<S-wheel-up>") #'text-scale-decrease)
    (my-env-add-map kmap)))
#+END_SRC

On Windows trackpad, we enable the text scaling and possibly using =M-mouse-1=
as =mouse-2=.

#+BEGIN_SRC emacs-lisp
(defun windows-trackpad ()
  (let ((kmap (make-sparse-keymap)))
    (define-key kmap (kbd "<S-wheel-down>") #'text-scale-decrease)
    (define-key kmap (kbd "<S-wheel-up>") #'text-scale-increase)
    (define-key key-translation-map (kbd "<M-down-mouse-1>") (kbd "<down-mouse-2>"))
    (define-key key-translation-map (kbd "<M-mouse-1>") (kbd "<mouse-2>"))
    (my-env-add-map kmap)))

(defun reset-windows-trackpad ()
  (define-key key-translation-map (kbd "<M-down-mouse-1>") nil)
  (define-key key-translation-map (kbd "<M-mouse-1>") nil))
#+END_SRC

*** Keyboard handling

On a us keyboard, we also want to be able to use german umlauts. This is
possible quite easily, courtesy of mule. =C-\= switches the default input
method on and off, so zou can activate it on your finger tips. Additionally,
select the default input method with =C-x RET C-\=. Practical are
/german-postfix/ (ae), /german-prefix/ ("a) or /german/ - the latter
activating a complete german keymapping, which is probably not too useful on a
us keyboard. Input methods are described by =C-h I=.

On a german keyboard, we want some of the more obscure mappings to be within
easier reach. This is done here for combinations otherwise unmapped.
Should be activated by customizing into my-environment-mode.
Augment as needed..

#+BEGIN_SRC emacs-lisp
(defun activate-german-keymap ()
  "activate some generic mappings to be reachable in usual places on german keyboard."
  (let ((kmap (make-sparse-keymap)))
    (define-key kmap "\242" #'mark-word) ; M-@, here M-"
    (define-key kmap "\246" #'delete-indentation) ; M-^, here M-&
    (define-key kmap "\C-x&" #'enlarge-window) ; C-x ^, here C-x &
    (define-key kmap "\C-x*" #'enlarge-window-horizontally) ; C-x }
    (define-key kmap "\C-xÜ" #'shrink-window-horizontally)  ; C-x {
    (define-key kmap [3 67108919] #'toggle-my-environment)
    (my-env-add-map kmap)))
#+END_SRC

**** Modifiers

The /Meta/ key should always be directly left and right of the space
bar. At least on the right side, there should be an /Alt/ key.
/Control/ should be also on the shift lock (defined on os level).
Additional keys may be mapped to /super/. Uses of /super/ and /hyper/
are to be explored.

On an Apple keyboard, we want to use the command keys as /Meta/, the
right alt as option, control as such and probably the left alt as
/super/. Btw, note you can get the /tilde/ with =S-A-8=.

#+BEGIN_SRC emacs-lisp
;; all mapping is done in vmware (Profil deutsch optimized for emacs),
;; so currenty no special handling here. Instead, activate defaults..
(setq w32-apps-modifier 'meta)
(setq w32-alt-is-meta 't)
(setq w32-lwindow-modifier nil)
(setq w32-pass-lwindow-to-system 't)

(defun on-apple-keyboard ()
  ;; (w32-register-hot-key [M-])
)
#+END_SRC

Similarly, on a PC keyboard, the left alt is /Meta/, the right als
used as /AltGr/.

#+BEGIN_SRC emacs-lisp
(defun on-pc-keyboard ()
)
#+END_SRC

*** Window handling

We overrule =C-x ^= to use our window resizing method.

#+BEGIN_SRC emacs-lisp
(global-set-key [remap enlarge-window] #'resize-window)
#+END_SRC

And upgrade fullscreen experience. Use =M-F10= to toggle between maximized
and a size comprised of almost full height and a width just below
~split-width-threshold~; =M-F11= to toggle fullscreen including no window
decorations.

#+BEGIN_SRC emacs-lisp
(global-set-key [remap toggle-frame-fullscreen] #'toggle-maximize-frame)
(global-set-key [remap toggle-frame-maximized] #'switch-frame)
(global-set-key (kbd "<M-f11>") #'toggle-maximize-frame)
#+END_SRC

*** Remote controlling other window

As I got quite used to remote control the other window using =C-x 4= keys, 
I'm adding a few ones which I missed so far.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x4q" #'quit-restore-other-window)
(global-set-key "\C-x4l" #'go-back-other-window)
(global-set-key "\C-x4-" #'shrink-other-window-if-larger-than-buffer)
(global-set-key "\C-x4s" #'dedicate-window)
(global-set-key "\C-x4e" #'edit-other-window)
#+END_SRC

Note the window size changing keys, =C-x ^= to enlarge (also negative) and
=C-x -= to shrink if buffer is smaller than window are a little bit asymetric.
While the enlargement key can be used to enlarge and shrink the current
window, the shrink key works only in one direction. So here we define an
adjacent key for the other window. For rescue, there is always =C-x += to
balance windows.

We also want to jump to beginning/end in other window by =C-M-<= and =C-M->=
(cf. =C-M-v= and =C-M-V= to scroll pagewise in other window).

#+BEGIN_SRC emacs-lisp
(global-set-key [201326652] #'beginning-of-other-window)
(global-set-key [201326654] #'end-of-other-window)
(global-set-key [remap scroll-other-window] #'my-scroll-other-window)
(global-set-key [remap scroll-other-window-down] #'my-scroll-other-window-down)
#+END_SRC

How to get these codes? Call =M-x global-set-key RET C-M-< beg=.. to manually
define such a key, then call =C-x ESC ESC= and copy the resulting parametrized
command from minibuffer.
Alternatively, call =M-: (read-key-sequence "> ")=.

Now come the key bindings for convenient error navigation, as promised above.

#+BEGIN_SRC emacs-lisp
(define-prefix-command 'other-goto-map)
(global-set-key "\C-x4\M-g" 'other-goto-map)
(define-key other-goto-map "\M-n" #'next-error-other-window)
(define-key other-goto-map "\M-p" #'previous-error-other-window)
#+END_SRC

Here we bind the temporary navigation mode to some useful keys for current and
other window.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x\C-v" (lambda () (interactive)(navigate-other-window 0)))
(global-set-key "\C-x4v" #'navigate-other-window)
#+END_SRC

*** Remote controlling other frame

Push current window buffer to own frame and revert current window to previous frame.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x5p" #'push-buffer-to-frame)
#+END_SRC

** Misc

Magit for windows passwd query doesn't work in minibuffer.

#+BEGIN_SRC emacs-lisp
(setenv "SSH_ASKPASS" "git-gui--askpass")
#+END_SRC

Load and enable different additional packages

#+BEGIN_SRC emacs-lisp
(setq org-element-use-cache nil)  ;; temporarily disable org element cache
(load-library "realgud")
(load-library "evil")
(require 'wdired)
(load "dired-x.el") ;; also enable C-x C-j
(require 'helm-config)
(require 'ox-rst)
(global-undo-tree-mode)
(global-magit-file-mode t)
(which-key-mode 1)

(setq erc-autojoin-channels-alist '(("freenode.net" "#latex-de" "##latinitas" "#NetBSD" "##bash-de" "#git" "#vim" "#emacs" "#erc" "#oberon" "#macosx")))
#+END_SRC

Accept simplified answers.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Mode-specific customizations
*** dired

Now that ~ediff~ is configured for use in ~magit~, also use it in ~dired~.

#+BEGIN_SRC emacs-lisp
(define-key dired-mode-map "="
  (lambda ()
    "ediff file at mark and file at point."
    (interactive)
    (let ((file (dired-get-filename))
          (prev (if mark-active 
                    (save-excursion (goto-char (mark t))(dired-get-filename))
                  nil)))
      (if (and file prev)
          (ediff-files prev file)))))
#+END_SRC

*** Evil mode

**** Evil defines

Here we implement some kind of .vimrc initialization.
This is also an example of defining an evil leader key and some adjacent keymaps.
Inspired by spacemacs, we experiment with rebinding the =C-x= and =C-c= maps.
They are accessable by =SPC x= and =SPC c=, while the =C-x= map is also parent
of leader map. This way, all unambiguous key commands should be directly
accessable by =SPC=. Lets see how this works out.

#+BEGIN_SRC emacs-lisp
(defun evil-rc ()
  "evil local init/customization"
  (define-prefix-command 'leader-map)

  (define-key evil-normal-state-map " " leader-map)
  ;; yes, we really want to scroll up in evil mode
  (define-key evil-normal-state-map "\C-u" #'evil-scroll-up)

  (define-key leader-map "#" #'list-buffers)
  (define-key leader-map "l" #'global-linum-mode)

  (define-key leader-map "x" (key-binding "\C-x"))
  (define-key leader-map "c" (key-binding "\C-c"))
  (set-keymap-parent leader-map (key-binding "\C-x"))

  (evil-define-state scroll "scroll-state"
    :tag " <S>"
    :message "-- SCROLL --"
    :suppress-keymap 't)
  (define-key evil-scroll-state-map "0" #'evil-digit-argument-or-evil-beginning-of-line)
  (define-key evil-scroll-state-map "j" (lambda nil
                                          (interactive)(evil-next-line)(call-interactively
                                                                        #'evil-scroll-line-to-center)))
  (define-key evil-scroll-state-map "k" (lambda nil
                                          (interactive)(evil-previous-line)(call-interactively
                                                                            #'evil-scroll-line-to-center)))
  (define-key evil-scroll-state-map (kbd "<escape>") 'evil-normal-state)
  (define-key evil-scroll-state-map "\C-\M-z" 'evil-emacs-state)
  (define-key leader-map "s" 'evil-scroll-state))
#+END_SRC

**** Evil Emacs config

When using evil-mode, set ~evil-exit-emacs-state~ to =C-M-z=, as I'm used to
~suspend-frame~. Additionally, always enter evil mode in emacs state (see custom). This
way, without getting in the way it is always only a key press away.

#+BEGIN_SRC emacs-lisp
(define-key evil-emacs-state-map "\C-z" nil)
(define-key evil-emacs-state-map "\C-\M-z" #'evil-exit-emacs-state)
(define-key evil-normal-state-map "\C-\M-z" #'evil-emacs-state)
#+END_SRC

Now, after Initializing evil, we may probably also activate it in all buffers.

#+BEGIN_SRC emacs-lisp
(evil-rc)
(evil-mode)
#+END_SRC

*** C++ mode customizations, in use for aeons now

#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
          (function
           (lambda ()
             (c-toggle-auto-hungry-state 1)
             (c-set-style "Stroustrup")
	     (setq c-basic-offset 2)
             (setq c-hanging-braces-alist '((brace-list-open)
                                            (brace-list-close after)
                                            (defun-open after)
                                            (class-open after)
                                            (inline-open after)
                                            (substatement-open after))))))
#+END_SRC

*** Auto-fill-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'fundamental-mode-hook
         (lambda () (auto-fill-mode 1)))
(add-hook 'text-mode-hook
         (lambda () (auto-fill-mode 1)))
(add-hook 'org-mode-hook
         (lambda () (auto-fill-mode 1)))
#+END_SRC

*** python mode

First of all, on Windows, make python usable within emacs when running in
comint buffers.

#+BEGIN_SRC emacs-lisp
(setenv "PYTHONUNBUFFERED" "x")
#+END_SRC

We use hippie-expand mapped to =M-/=

#+BEGIN_SRC emacs-lisp
(global-set-key [remap dabbrev-expand] #'hippie-expand)
#+END_SRC

We want to use flycheck in python.

#+BEGIN_SRC emacs-lisp
(require 'flycheck)
#+END_SRC

~elpy-mode~ defines a bunch of useful support functions for navigating and
indenting in python buffers. Notably =C-c C-d= documentation for item under
point, =M-.= jump to definition of item under cursor, =M-*= pop back to where
=M-.= was last invoked, =C-c C-o= show all python definitions of current
buffer in occur view, =C-c C-z= switch to python shell.
For this, set ~python-shell-interpreter~ to path of buildout powerscript exe and
~python-shell-interpreter-args~ to "" (see custom).
Also worth to remember the company backend completion on =C-M-i=.

Note: ~elpy-enable~ adds to ~python-mode-hook~ only on first call. So if you
re-evaluate ~custom.el~, remember to afterwards ~(setq elpy-enabled-p nil)~
and ~(elpy-enable)~.

#+BEGIN_SRC emacs-lisp
(elpy-enable)
#+END_SRC

To navigate using more convenient keys, we put the block navigation moves
(block in, block out, within block up and down) to =f=, =b=, =p= and =n=
combined with =C-M=. Other useful functions already on convenient keys are
=S-RET= open and indent line below, =C-S-RET= open and indent line above.
Also the python indentation functions (=C-c <= and =C-c >=) are remapped to
elpy. The =M-i= and =M-I= bindings first have to prove themselves.

#+BEGIN_SRC emacs-lisp
(define-key elpy-mode-map "\C-\M-p" #'elpy-nav-backward-block)
(define-key elpy-mode-map "\C-\M-n" #'elpy-nav-forward-block)
(define-key elpy-mode-map "\C-\M-f" #'elpy-nav-forward-indent)
(define-key elpy-mode-map "\C-\M-b" #'elpy-nav-backward-indent)
(define-key elpy-mode-map "\M-i" #'elpy-nav-indent-shift-right)
(define-key elpy-mode-map "\M-I" #'elpy-nav-indent-shift-left)
(define-key elpy-mode-map [remap python-indent-shift-right] #'elpy-nav-indent-shift-right)
(define-key elpy-mode-map [remap python-indent-shift-left] #'elpy-nav-indent-shift-left)
#+END_SRC

The visibility toggling is on completely brain damaged keys, so we put at
least the toggle at point function at =S-tab=, being as convenient as in org
mode.

#+BEGIN_SRC emacs-lisp
;; (w32-register-hot-key (kbd "<M-tab>")) ; example of hot key override, but not practical
(define-key elpy-mode-map (kbd "<S-tab>") #'elpy-folding-toggle-at-point)
#+END_SRC

Enable autopep8, but don't activate it on save. However, use =M-g M-n= and
=M-g M-p= for flycheck next and flycheck previous error, which also show pep8 errors.

#+BEGIN_SRC emacs-lisp
(require 'py-autopep8)
;;(add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
(define-key elpy-mode-map [remap previous-error] #'flycheck-previous-error)
(define-key elpy-mode-map [remap next-error] #'flycheck-next-error)
#+END_SRC

elpy makes indentation levels visible columnwise, so we also highlight the
current line of point.
As this is not only for python, currently enabled only in customize.

#+BEGIN_SRC emacs-lisp
;; (global-hl-line-mode)
#+END_SRC

The untabify-function defined here is disabled. Instead, we use custom
variable ~indent-tabs-mode~. Nevertheless, this may serve as an example, so it
stays here. custom python mode hook also activates jedi and superword mode.

#+BEGIN_SRC emacs-lisp
;; (defun python-mode-untabify ()
;;     (save-excursion
;;       (goto-char (point-min))
;;       (while (re-search-forward "[ \t]+$" nil t)
;;         (delete-region (match-beginning 0) (match-end 0)))
;;       (goto-char (point-min))
;;       (if (search-forward "\t" nil t)
;;           (untabify (1- (point)) (point-max))))
;;     nil)

;;(add-hook 'python-mode-hook
;;            '(lambda ()
;;               (make-local-variable 'write-contents-hooks)
;;               (add-hook 'write-contents-hooks 'python-mode-untabify)))
#+END_SRC

*** React programming

Combine javascript and web-mode, supporting ~jsx~ templates within. This is
probably outdated and should be re-evaluated. Is there already a real
react-mode? Otherwise, combine it with more up-to-date html-mode?

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.jsx\\'" . web-mode))
(add-hook 'web-mode-hook 'js2-minor-mode)
#+END_SRC

*** XML-mode 

**** hiding of subtrees

Here we use ~hs-mode~, enabling tag view toggling and tag level hiding. Also
~S-mouse-2~ can be used to toggle tag views.

#+BEGIN_SRC emacs-lisp
(setq sgml-quick-keys t)
(require 'hideshow)
(require 'sgml-mode)
(require 'nxml-mode)

(add-to-list 'hs-special-modes-alist
             '(nxml-mode
               "<!--\\|<[^/>]*[^/]>"
               "-->\\|</[^/>]*[^/]>"

               "<!--"
               sgml-skip-tag-forward
               nil))

(add-hook 'nxml-mode-hook 'hs-minor-mode)

(define-key nxml-mode-map (kbd "C-c C-h") 'hs-toggle-hiding)
(define-key nxml-mode-map (kbd "C-c C-l") 'hs-hide-level)
#+END_SRC

**** tagedit-mode

tbd

*** smartparens mode

In emacs lisp, we want slurp and barf support via smartparens. As the default
conflicts with my habits, we define our own mapping here.
Also use our delimiter for parens.

#+BEGIN_SRC emacs-lisp
(require 'smartparens-config)
(sp--populate-keymap
 (let ((my-sp-bindings '(("C-M-f" . sp-forward-sexp) ;; navigation
                         ("C-M-b" . sp-backward-sexp)
                         ("C-M-u" . sp-backward-up-sexp)
                         ("C-M-d" . sp-down-sexp)
                         ("C-M-p" . sp-backward-parallel-sexp)
                         ("C-M-n" . sp-forward-parallel-sexp)
                         ("C-M-k" . sp-kill-sexp)
                         ("C-M-w" . sp-copy-sexp)
                         ("M-F" . sp-forward-symbol)
                         ("M-B" . sp-backward-symbol)
                         ("C-M-SPC" . sp-mark-sexp)
                         ("C-c s" . sp-splice-sexp) ;; depth-changing commands
                         ("C-c S" . (lambda (point mark pre) (interactive "r\nP") (my-delimit-region point mark pre ?\()))
                         ("C-c b" . sp-splice-sexp-killing-backward)
                         ("C-c f" . sp-splice-sexp-killing-forward)
                         ("C-c k" . sp-splice-sexp-killing-around)
                         ("C-c )" . sp-forward-slurp-sexp) ;; barf/slurp
                         ("C-c }" . sp-forward-barf-sexp)
                         ("C-c (" . sp-backward-slurp-sexp)
                         ("C-c {" . sp-backward-barf-sexp)
                         ("C-c C-s" . sp-split-sexp)
                         ("C-c C-]" . sp-select-next-thing-exchange)
                         ("C-c ]" . sp-select-next-thing)
                         )))
   my-sp-bindings))
(add-hook 'emacs-lisp-mode-hook #'smartparens-mode)
#+END_SRC

*** markdown mode

#+BEGIN_SRC emacs-lisp
(autoload 'markdown-mode "markdown-mode"
  "Major mode for editing Markdown files" t)
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
(setq markdown-command "/Users/jko/Programming/node/node_modules/.bin/md2html")
#+END_SRC

** Disabled commands

#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
(put 'narrow-to-page 'disabled nil)
(put 'set-goal-column 'disabled nil)
#+END_SRC

** Todo
*** TODO make window resize steps customizable, add center function
*** TODO split custom.el into site specific customization and global custom selection to be merged/distributed
    - move mergeable options into init-babel.org?
*** TODO read about tramp plugins
*** TODO macro for command composition
    - compose key 1 and key 2
    - assign function name
    - where-is-internal - find key bindings for function
    - key-binding - find function for key binding
*** TODO complete mouse/trackpad handling/switching
*** DONE display-buffer
**** DONE option close frame on quit instead of iconify
     - frame-auto-hide-function to delete
**** DONE build a function scaling selected window to fit buffer, but use max arg fract of frame
     - fit-window-to-buffer-max-half-frame
**** DONE how to make window dedicated? that is not 'dedicated' to a buffer, but not selected as other window
     - probably mitigated by not using display-buffer-use-some-window
**** DONE continue experiments with-current-buffer
**** DONE read display-buffer
**** DONE check dired buffer handling
     - experiment with logging display-buffer function
*** DONE find out about alist handling
*** DONE finetune nth-window and other window handling
    - s f. other-window-for-scrolling and v. other-window-scroll-buffer
    - select other window:
      - probably tag different windows with dedication tags (main work
        window, dired window, info/help window)
      - advice display-buffer functions not to use these
    - or define own actions
    - first see display-buffer docs
*** DONE complete keyboard switching
*** DONE cleanup misc, move to mode specific sections
*** DONE env-mode: use make-composed-keymap, set-keymap-parent
    this way, each action can define an own keymap indefinitely existing and
    just adding/removing it on enter/exit. Advantage is, rebind commands
    should also be effective on these existing keymaps.
    - also: call first toggle-my-environment on mode init. So if envs are
      defined, we are always in one of the valid states.
*** DONE think about movement/search placing point on beginning of adjacent object
    done at least for searching
