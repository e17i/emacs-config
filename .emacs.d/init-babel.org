#+TITLE: Jörgs Emacs init
* Emacs Configuration
** Lisp functions
*** Initialization

We want to set each frame to reasonable color defaults by defining an
appropriate hook. We also call it for the current frame.

#+BEGIN_SRC emacs-lisp
(defgroup my-cust nil "my customizations")
(defcustom my-frame-transparency 100
  "transparency used for all display frames."
  :type '(integer)
  :group 'my-cust
  :set (lambda (symb val)
         (setq my-frame-transparency val)
         (dolist (frame (frames-on-display-list))
           (set-frame-parameter frame 'alpha `(,val . ,val)))))
(add-hook 'after-make-frame-functions
	  (lambda (frame)
	    (set-frame-parameter frame 'alpha (cons my-frame-transparency my-frame-transparency))
	    (with-selected-frame frame
	      (set-background-color "Black")
	      (set-foreground-color "Green")
	      )))
#+END_SRC

*** Handling of other window

First of all, a topic of long and outstanding troubles has been the question
of seemingly eratically selecting the other window. As it seems, this is
actually a quite deterministic operation. Its frontend is ~pop-to-buffer~, the
implementation and documentation is in ~display-buffer~. There, a range of
~display-buffer-functions~ can be selected and combined at will, generating
this behaviour. Now, often you may want to craft a window configuration into
your frame, so you dont want any of this to be misused. Here, the following
functions come in handy. Use them to define your dedicated 'other' window.

Activate by customizing ~display-buffer-alist~, inserting
~display-buffer-dedicated-window~. Also interesting are functions like
~display-buffer-pop-up-frame~.

#+BEGIN_SRC emacs-lisp
(defvar dedicated-other-window nil)

(defun dedicate-window (arg)
  "Dedicate the currently selected window as 'other' window. When
called with a =C-u= prefix arg, releases the previously set window
and reverts to the default window selection behaviour."
  (interactive "p")
  (setq dedicated-other-window
        (if (eq arg 4)
            nil
          (selected-window)))
  (if dedicated-other-window
      (progn
        (setq other-window-scroll-buffer
              (with-selected-window dedicated-other-window
                (current-buffer)))
        (message "window dedicated"))
    (message "dedication removed")))

(defun display-buffer-dedicated-window (buffer alist)
  "Always display pop-up-buffer in the dedicated other window, if selected. If
none is selected, revert to the default behaviour."
  (if (and (not alist)
           dedicated-other-window
           (window-live-p dedicated-other-window))
      (with-selected-window dedicated-other-window
        (switch-to-buffer buffer))
    nil))
#+END_SRC

This sorted out, I'm adding some useful functions for handling the other
window. This can be handy after calling or navigating within help texts for
example.

First, a macro defining such functions. Default is to address the next window,
but you can specify one with a prefix arg.

#+BEGIN_SRC emacs-lisp
(defmacro nth-window (fname docstring &rest body)
  "Defines an interactive function performing the forms in BODY
 in other window or window specified by prefix arg. Uses FNAME as
 function name and describes it with DOCSTRING."
  `(defun ,fname (arg)
     ,docstring
     (interactive "p")
     (let ((scroll-window (get-buffer-window other-window-scroll-buffer)))
       (save-selected-window
         (if (and (eq arg 1)  ; no prefix arg
                  (buffer-live-p other-window-scroll-buffer)
                  (window-live-p scroll-window))
             (select-window scroll-window)
           (other-window arg))
         ,@body))))
#+END_SRC

The same for frames might also come in handy.

#+BEGIN_SRC emacs-lisp
(defmacro nth-frame (fname docstring &rest body)
  "Defines an interactive function performing the forms in BODY
 in other frame or frame specified by prefix arg. Uses FNAME as
 function name and describes it with DOCSTRING."
  `(defun ,fname (arg)
     ,docstring
     (interactive "p")
     (let ((current (selected-frame)))
       (other-frame arg)
       ,@body
       (select-frame-set-input-focus current))))
#+END_SRC

And now some other-window-functions.

#+BEGIN_SRC emacs-lisp
(nth-window go-back-other-window
  "Go back to previous help topic in other window."
  (help-go-back))

(nth-window quit-restore-other-window
  "Quit other window and deal with its buffer, possibly restoring
      the buffer previously displayed in other window."
  (quit-restore-window (selected-window)))

(nth-window shrink-other-window-if-larger-than-buffer
  "Shrink height of other window if its buffer doesn't need so many lines."
  (shrink-window-if-larger-than-buffer))

(nth-window beginning-of-other-window
  "Like `beginning-of-buffer-other-window', but use prefix arg to select window."
  (beginning-of-buffer))

(nth-window end-of-other-window
  "Like `end-of-buffer-other-window', but use prefix arg to select window."
  (end-of-buffer))
#+END_SRC

*** Convenient error stepping

Often I want to quickly navigate through a list of error messages or
occurencies, jumping to the places the errors are indicating. There are
different ways to archieve this. First of all, with =C-x C-f= you can activate
~error-follow-minor-mode~, allowing to move the mark through the error buffer,
letting the referenced source buffers follow you. But if you want to have the
source buffer active, you would need to jump to the error buffer for each next
step. As a remedy, the following functions are introduced. While they follow
the previous scheme adding remote control functions for the other window, they
also show a cool feature of setting a temporary keymap in place, allowing
further navigation steps by using shortcuts. This way, the long key sequence
of addressing the other window (=C-x 4=) and starting the goto sequence
(=M-g=) needs to be casted only as an initiation. Afterwards, it gets really
easy. This is quite convenient in the most different applications.

#+BEGIN_SRC emacs-lisp
(require 'cl)

(defun error-step ()
  (macrolet ((step-msg ()
		       '(message "Use n,p,< to navigate further")))
    (step-msg)
    (set-transient-map
     (let ((map (make-sparse-keymap)))
       (dolist (modk '(() (meta)))
	 (define-key map (vector (append modk '(?n)))
	   (lambda () (interactive) (next-error) (step-msg)))
	 (define-key map (vector (append modk '(?<)))
	   (lambda () (interactive) (first-error) (step-msg)))
	 (define-key map (vector (append modk '(?p)))
	   (lambda () (interactive) (previous-error) (step-msg))))
       map) 't)))

(defun next-error-other-window (&optional arg)
  "Visit next error message displayed in other window's buffer. With prefix arg, jump to nth error."
  (interactive "P")
  (with-current-buffer (window-buffer (next-window))
    (next-error arg)
    (error-step)))

(defun previous-error-other-window (&optional arg)
  "Visit previous error message displayed in other window's buffer. With prefix arg, jump to nth error."
  (interactive "P")
  (with-current-buffer (window-buffer (next-window))
    (previous-error arg)
    (error-step)))
#+END_SRC

*** Convenient Navigation Mode

This is an experimental feature in the spirit of previous means of other
window handling, allowing for activation of a temporary navigation mode. Using
this, you can conveniently navigate, scroll, set marks and jump to previous
mark positions. Features include navigating up and down of the point,
scrolling up and down, jumping to begin and end of buffer, pagewise up and
down. Most of these can be combined with a numeric argument. The mode is
cancelled by using any other key.

#+BEGIN_SRC emacs-lisp
(defun navigate-buffer (&optional window)
  "Enter a temporary buffer navigation mode. WINDOW specifies an optional window pointer,
allowing to specify a remote window to be controlled."
  (lexical-let ((arg-acc 0) (arg-neg nil) (consumed nil)
		(window (or window (selected-window))))
    (labels ((set-consumed () (setq consumed 't))
	     (acc-reset ()
			(if consumed
			    (setq arg-acc 0 arg-neg nil consumed nil)))
	     (get-arg-acc (&optional default)
			  (let ((res (if (> arg-acc 0)
					 (* arg-acc (if arg-neg -1 1))
				       default)))
			    res))
	     (acc-status () (message "navigate ([-,0-9] n,p,N,P,v,V,<,>,[,],l, ) %c %d"
				     (if arg-neg arg-neg '? ) arg-acc))
	     (arg-negate ()
			 (setq arg-neg (if arg-neg nil '?-))
			 (acc-status))
	     (arg-accumulate (num)
			     (setq arg-acc (+ (* arg-acc 10) num))
			     (acc-status)))
      (macrolet ((with-window (&rest body)
			      `(lambda () (interactive)
				 (set-consumed)
				 (with-selected-window window
				   ,@body
				   (acc-status)))))
	(acc-status)
	(set-transient-map
	 (let ((map (make-sparse-keymap)))
	   (define-key map [?-] (lambda () (interactive) (acc-reset) (arg-negate)))
	   (dolist (num '(?0 ?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9))
	     (define-key map (vector num)
	       (lambda ()
		 (interactive)
		 (acc-reset)
		 (let* ((ev last-command-event)
			(base (event-basic-type ev)))
		   (arg-accumulate (- base 48))))))
	   (define-key map " " (with-window
				(if (eq arg-acc 0)
				    (progn (set-mark-command nil)(deactivate-mark))
				  (set-mark-command (get-arg-acc)))))
	   (define-key map "n" (with-window (next-line (get-arg-acc 1))))
	   (define-key map "p" (with-window (previous-line (get-arg-acc 1))))
	   (define-key map "/" (with-window (isearch-forward))) ;not documented
	   (define-key map "l" (with-window (recenter-top-bottom (get-arg-acc))))
	   (define-key map "r" (with-window (move-to-window-line-top-bottom (get-arg-acc))))
	   (define-key map "<" (with-window (beginning-of-buffer (get-arg-acc))))
	   (define-key map ">" (with-window (end-of-buffer (get-arg-acc))))
	   (define-key map "]" (with-window (forward-paragraph (get-arg-acc))))
	   (define-key map "[" (with-window (backward-paragraph (get-arg-acc))))
	   (define-key map "N" (with-window (scroll-up-line (get-arg-acc 1))))
	   (define-key map "P" (with-window (scroll-down-line (get-arg-acc 1))))
	   (define-key map "v" (with-window (scroll-up-command (get-arg-acc))))
	   (define-key map "V" (with-window (scroll-down-command (get-arg-acc))))
	 map) 't)))))

(nth-window navigate-other-window
  "Enter a temporary buffer navigation mode, allowing some window to be
controlled remotely. Default is the other window. Optional argument
selects the nth window. This allows moving around some window without
de-selecting the current window, enabling a very convenient means of
temporarily moving around. 

Keys are:
  -, 0-9: set an argument to following commands, which stays in effect until
          reset (e.g. by pressing 0)
  space: set a mark; with arg jump to mark
  n, p: move point to next/previous line
  l: recenter buffer to point
  r: move point to window center
  <, >: move point to beginning/end of buffer
  [, ]: move point forward/backward in paragraphs
  N, P: scroll up/down
  v, V: pagewise scroll up/down"
  (navigate-buffer))
#+END_SRC

*** Frame and window size

Interactively resize windows.

#+BEGIN_SRC emacs-lisp
(defun resize-window ()
  "Resize current window interactively using continuous key presses.
Keys supported:

 - shrink window vertically
 + enlarge window vertically
 [ shrink window horizontally
 ] enlarge window horizontally
 0 balance all frames window sizes"
  (interactive)
  (macrolet ((msg ()
		  '(message "resize window (-,+,{,},0)"))
	     (lmb (fnc)
		  `(lambda () (interactive)
		     (msg)
		     ,fnc)))
    (msg)
    (set-transient-map
     (let ((tmap (make-sparse-keymap)))
       (define-key tmap "0" (lmb (balance-windows)))
       (define-key tmap "-" (lmb (shrink-window 1)))
       (define-key tmap "+" (lmb (enlarge-window 1)))
       (define-key tmap "=" (lmb (enlarge-window 1))) ; easy access on us keyboard
       (define-key tmap "^" (lmb (enlarge-window 1))) ; reuse entry key
       (define-key tmap "&" (lmb (enlarge-window 1))) ; german keyboard
       (define-key tmap "{" (lmb (shrink-window-horizontally 1)))
       (define-key tmap "Ü" (lmb (shrink-window-horizontally 1))) ; german keyboard, here "U
       (define-key tmap "}" (lmb (enlarge-window-horizontally 1)))
       (define-key tmap "*" (lmb (enlarge-window-horizontally 1))) ; german keyboard
       tmap) 't)))
#+END_SRC

This used to be a frame maximize function for Mac, which is not longer neeeded
here. Nevertheless, this may work as foundation for functions realizing some
visually attractive full screen mode and reverting to the previous frame size.
"Visually attractive" would then be something like "leave a small configurable
space outside the frame and use the rest of screen".

#+BEGIN_SRC emacs-lisp
(defun switch-frame ()
  "Set frame to reasonable position and size based on some heuristics.
  Alternatively, toggles size to maximized."
  (interactive)
  (let ((maximized (frame-parameter nil 'fullscreen)))
    (cond
     ((eq maximized 'maximized)
      (let ((lines (frame-parameter nil 'height)))
	(set-frame-parameter nil 'fullscreen nil)
	(set-frame-width nil (- split-width-threshold 1))
	(set-frame-height nil (- lines 1))
	(set-frame-position nil 0 8)))
     ((eq maximized nil)
      (set-frame-parameter nil 'fullscreen 'maximized)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun toggle-maximize-frame ()
  "Toggle fullscreen and switch off menu bar and scroll bar."
  (interactive)
  (labels ((set-scroll-bar (where) (customize-set-variable 'scroll-bar-mode where)))
    (let ((fullscreen (frame-parameter nil 'fullscreen)))
      (cond
       ((memq fullscreen '(fullscreen fullboth))
	(set-scroll-bar (frame-parameter nil 'scrollbar))
	(set-frame-parameter nil 'scrollbar nil)
        (apply (get 'my-frame-transparency 'custom-set) 'my-frame-transparency
               (frame-parameter nil 'my-transparency) nil)
        (set-frame-parameter nil 'my-transparency nil)
	(toggle-menu-bar-mode-from-frame 1)
        (toggle-frame-fullscreen))
       ((eq fullscreen nil)
	(set-frame-parameter nil 'scrollbar scroll-bar-mode)
	(menu-bar-no-scroll-bar)
	(set-frame-parameter nil 'my-transparency my-frame-transparency)
        (apply (get 'my-frame-transparency 'custom-set) 'my-frame-transparency 100 nil)
	(toggle-menu-bar-mode-from-frame 0)
        (toggle-frame-fullscreen))))))
#+END_SRC

*** electric delimiter

Often I want to put some text into delimiters after writing it, for example a
string or an argument list. So the reverse of a splicing operation is needed.
Here, you can define a region and delimit it using a character. In the special
case of the character being an opening type of brace, automatically selects
the corresponding closing brace. When called with prefix arg, the region is
newly indented after delimiting.

#+BEGIN_SRC emacs-lisp
(defun my-delimit-region (&optional pre delim)
  "Frame region with delimiters. If delim is an opening type of
brace, automatically use the corresponding closing delimiter,
otherwise use the same char for both sides. If called
interactively, take next key press as opening delimiter. If
called with prefix arg, the region is newly indented after
delimiting."
  (interactive "P")
  (let* ((bd (if delim delim
               (read-event "> ")))
         (ed (case bd
               ((?\() ?\))
               ((?\[) ?\])
               ((?{) ?})
               ((?<) ?>)
               (t bd))))
    (let ((p1 (if (> (point) (mark)) (mark) (point)))
          (p2 (if (> (point) (mark)) (point) (mark))))
      (save-excursion
        (goto-char p1)
        (insert bd)
        (goto-char (+ p2 1))
        (insert ed))
      (if pre (indent-region p1 p2)))))
#+END_SRC

*** Push buffer to frame

Sometimes, auxiliary buffers to be displayed in the 'other' window are
eratically pushed into some well arranged window. While this can be configured
through action variables used by ~display-buffer~, this is a complex and
error-prone configuration. To mitigate, use this function to push it into its
own frame and revert the previously crafted window arrangement.

This also calls a little bit for some further 'remote control other frame'
functions..

#+BEGIN_SRC emacs-lisp
(defun push-buffer-to-frame ()
  "push current window buffer to own frame and revert current window to previous frame."
  (interactive)
  (let ((current (current-buffer))
        (selected (selected-window)))
    (if (display-buffer-other-frame current)
        (quit-restore-window selected))))
#+END_SRC

** Environment Minor Mode
We want to easily be able to switch between different environments. For
example, using a notebook in mobile or in docked mode may mean using mouse or
trackpad, apple or pc keyboard. This is implemented in a global minor mode,
binding a hot key as environment toggle. Each environment is designated by an
id character shown in the mode line and a list of actions. Each action has
enter and exit functions to setup and leave the corresponding action. This
way, actions can be defined in terms of (lambda) functions. Also an action can
be part of different environments.
After customizing the mode, use =C-c C-\= to toggle through environments.

#+BEGIN_SRC emacs-lisp
(defgroup my-environment nil "my environments")

(defcustom my-env-actions nil
  "list of actions. Each element has the form (symb enter-fnc
exit-fnc), where symb is a symbol used to address this definition, enter-fnc
and exit-fnc are functions to setup and leave the corresponding state."
  :type '(repeat (list symbol function function))
  :group 'my-environment)

(defcustom my-env-definitions nil
  "list of environments to toggle through. Each definition has the form (id
(list of symbols)), where id is a character shown in the mode
line describing the current environment. Then follows a list of
action symbols. Each of these actions is entered when
environment is toggled on and exited when another environment
is selected. If only one env is defined, toggles between this
only, so you should probably at least define a second env with
a default N id and no actions."
  :type '(repeat (list character (repeat symbol)))
  :group 'my-environment)

(defun my-env-init-keymap ()
  "setup a keymap for my-environment-mode, inserting the env toggle hot key."
  (define-prefix-command 'my-env-map)
  (let ((kmap (make-sparse-keymap)))
    (define-key kmap "\C-c" my-env-map)
    (define-key my-env-map "" #'toggle-my-environment)
    kmap))

(defun my-env-add-map (kmap)
  "Use this function in your enter action definitions to add sparse keymaps to the current environment."
  (pushnew kmap my-env-maps))

(defun my-env-remove-map (kmap)
  "Use this function in your exit action definitions to remove sparse keymaps from the current environment."
  (setq my-env-maps (remote-if (lambda (elem)
                                 (eq elem kmap))
                               my-env-maps)))

(define-minor-mode my-environment-mode
  "Minor mode supporting easy switching between different environments. For
example, using a notebook in mobile or in docked mode may mean using mouse or
trackpad, apple or pc keyboard.

\\{my-environment-mode-map}"
  nil
  " [N]"
  (my-env-init-keymap)
  :group 'my-environment
  :global 't
  :after-hook (toggle-my-environment))
#+END_SRC

You may add key definitions in enter action
functions with ~my-env-add-map~.
To remove them on exit, if you dont declare an exit function, as a convenience
use =my-env-reset-keymap=.

#+BEGIN_SRC emacs-lisp
(defun my-env-reset-keymap ()
  "If your enter function added to the minor mode or my-env keymaps, your exit
function should call this function to reset it."
  (setq my-env-maps nil))
#+END_SRC

*** Internals

#+BEGIN_SRC emacs-lisp
(defvar my-env-action nil) ; current env cell. car is the env, cdr the next cell..

(defvar my-env-maps nil) ; list of maps to combine into current env
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my-env-update-parent-map ()
  "creates a parent for the minor mode composing all current action maps."
  (set-keymap-parent my-environment-mode-map (make-composed-keymap my-env-maps)))

(defun my-env-enter-action (action)
  "calls the enter definition of given action if provided."
  (let ((aclist (remove-if-not (lambda (elem)
                                 (eq action (car elem)))
                               my-env-actions)))
    (if (and aclist (cadar aclist))
        (funcall (cadar aclist)))))

(defun my-env-exit-action (action)
  "calls the exit definition of given action if provided."
  (let ((aclist (remove-if-not (lambda (elem)
                                 (eq action (car elem)))
                               my-env-actions)))
    (if (and aclist (caddar aclist))
        (funcall (caddar aclist)))))

(defun toggle-my-environment ()
  "toggles activation of next environment. If only one env is defined, toggles
between this only, so you should probably at least define a second env with a
default N id and no actions."
  (interactive)
  (let ((current my-env-action)
        (next
         (if (not my-env-action)
             my-env-definitions
           (let ((next-first
                  (cdr my-env-action)))
             (if (not next-first)
                 my-env-definitions
               next-first)))))
    (if current
        (let ((env (car current)))
          (dolist (action (cadr env))
            (my-env-exit-action action))))
    (if next
        (let ((env (car next)))
          (dolist (action (cadr env))
            (my-env-enter-action action))
          (my-env-update-parent-map)
          (my-env-update-lighter (format " [%c]" (car env)))))
    (setq my-env-action next)))

(defun my-env-update-lighter (lighter)
  "update the lighter of minor mode to reflect the selected environment."
  (setcar
   (cdar (remove-if-not (lambda (elem)
                          (eq (car elem) 'my-environment-mode))
                        minor-mode-alist))
   lighter)
  (force-mode-line-update 't))
#+END_SRC

** Global key bindings
*** Generic

Some convenience keys for handling buffers and files. Use caution and check to
not shadow future functionality here.
We replace =C-x C-f= with ~find-file~, as the ~-at-point~ function is then
still reachable through =M-n=. The old mapping of =C-c C-f= to
~find-file-at-point~ is removed, as it is now overlayed by org.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x\C-b" #'bs-show)	;; this used to be electric-buffer-list
(global-set-key "\C-x\C-f" #'find-file)
(global-set-key [3 67108919] #'toggle-my-environment)  ;; make global to enable env switch on german kbd
#+END_SRC

And my delimiting function:

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cF" #'my-delimit-region)
#+END_SRC

*** Convenience for searching

Often you want to finish a search leaving the point on the first character of
the string found. This enables using isearch as a convenient tool for
positioning, selecting or killing to but not including a string. This is
enabled here on =C-return=.

#+BEGIN_SRC emacs-lisp
(define-key isearch-mode-map (kbd "<C-return>")
  (lambda () (interactive)
    (isearch-repeat (if isearch-forward
                        'backward
                      'forward))
    (isearch-exit)))
#+END_SRC

*** Scrolling

Convenience keys for buffer scrolling. Enables up/down also with /Meta/
modifier. Together with /Shift/ this enables scrolling. This way you can very
conveniently move the pointer and scroll by just adding/releasing the /Shift/
modifier.

#+BEGIN_SRC emacs-lisp
(global-set-key "\M-p" #'previous-line)
(global-set-key "\M-n" #'next-line)
(global-set-key "\M-P" #'scroll-down-line)
(global-set-key "\M-N" #'scroll-up-line)
(global-set-key [end] #'move-end-of-line)
(global-set-key [home] #'move-beginning-of-line)
#+END_SRC

*** Ace zapping

Ace enables some more vi-style jumping and zapping (see =M-z= for the basic
~zap-to-char~ function).

#+BEGIN_SRC emacs-lisp
(global-set-key "\M-J" #'ace-jump-char-mode)
;;;(global-set-key "\C-x\C-j" #'ace-jump-mode-pop-mark) ;; this is dired-jump
(global-set-key "\C-x\C-z" #'zzz-up-to-char)
#+END_SRC

*** Mouse handling

Mouse keys: remember basic mouse button handling in emacs: left - set pointer,
double left - select word, triple left - select line, drag - select, drag
after double - select words, right - define region and save to kill ring,
right after double click - define region up to next word, double right - kill
to kill ring, middle - yank to click position.

As on Mac middle button may be otherwise occupied, use mouse-3
together with /Meta/ as replacement.

~mouse-wheel-mode~ also enables mouse wheel scrolling. With /Meta/,
enables scroll turbo; with /shift/, scale text (seems to work only on
trackpad, as it is mapped to =S-wheel-left= / =right=).

#+BEGIN_SRC emacs-lisp
;; mac trackpad: select: mouse-1, copy/cut: mouse-3, yank: M-mouse-3
;; undo: C-M-mouse-3
;; as a convenience, on mode line M-mouse-1 is also mouse-2
;; (define-key key-translation-map (kbd "<M-mouse-3>") (kbd "<mouse-2>"))
;; (global-set-key [C-M-mouse-3] 'undo)
(define-key key-translation-map (kbd "<mode-line> <M-mouse-3>") (kbd "<mode-line> <mouse-2>"))
(define-key key-translation-map (kbd "<mode-line> <M-mouse-1>") (kbd "<mode-line> <mouse-2>"))
(global-set-key [M-mouse-3] #'mouse-yank-at-click)
;; mac mouse: select: mouse-1, copy/cut: mouse-3, yank: M-mouse-2,
;; undo: M-mouse-3
(global-set-key [M-mouse-2] #'mouse-yank-at-click)
(global-set-key [M-mouse-3] #'undo)
#+END_SRC

When using a mouse wheel, we also want to use the text size zooming feature which
in wheel-mode apparently works only with trackpad.

#+BEGIN_SRC emacs-lisp
(defun my-wheel-zoom ()
  (let ((kmap (make-sparse-keymap)))
    (define-key kmap (kbd "<S-wheel-down>") #'text-scale-increase)
    (define-key kmap (kbd "<S-wheel-up>") #'text-scale-decrease)
    (my-env-add-map kmap)))
#+END_SRC

*** Keyboard handling

On a us keyboard, we also want to be able to use german umlauts. This is
possible quite easily, courtesy of mule. =C-\= switches the default input
method on and off, so zou can activate it on your finger tips. Additionally,
select the default input method with =C-x RET C-\=. Practical are
/german-postfix/ (ae), /german-prefix/ ("a) or /german/ - the latter
activating a complete german keymapping, which is probably not too useful on a
us keyboard. Input methods are described by =C-h I=.

On a german keyboard, we want some of the more obscure mappings to be within
easier reach. This is done here for combinations otherwise unmapped.
Should be activated by customizing into my-environment-mode.
Augment as needed..

#+BEGIN_SRC emacs-lisp
(defun activate-german-keymap ()
  "activate some generic mappings to be reachable in usual places on german keyboard."
  (let ((kmap (make-sparse-keymap)))
    (define-key kmap "\242" #'mark-word) ; M-@, here M-"
    (define-key kmap "\246" #'delete-indentation) ; M-^, here M-&
    (define-key kmap "\C-x&" #'enlarge-window) ; C-x ^, here C-x &
    (define-key kmap "\C-x*" #'enlarge-window-horizontally) ; C-x }
    (define-key kmap "\C-xÜ" #'shrink-window-horizontally)  ; C-x {
    (define-key kmap [3 67108919] #'toggle-my-environment)
    (my-env-add-map kmap)))
#+END_SRC

**** Modifiers

The /Meta/ key should always be directly left and right of the space
bar. At least on the right side, there should be an /Alt/ key.
/Control/ should be also on the shift lock (defined on os level).
Additional keys may be mapped to /super/. Uses of /super/ and /hyper/
are to be explored.

On an Apple keyboard, we want to use the command keys as /Meta/, the
right alt as option, control as such and probably the left alt as
/super/. Btw, note you can get the /tilde/ with =S-A-8=.

#+BEGIN_SRC emacs-lisp
(defun on-apple-keyboard ()
  (custom-set-variables
   '(ns-control-modifier 'control)
   '(ns-alternate-modifier 'super)
   '(ns-right-alternate-modifier 'alternate)
   '(ns-command-modifier 'meta)
   '(ns-right-command-modifier 'meta)))
#+END_SRC

Similarly, on a PC keyboard, the left alt is /Meta/, the right als
used as /AltGr/.

#+BEGIN_SRC emacs-lisp
(defun on-pc-keyboard ()
  (custom-set-variables
   '(ns-control-modifier 'control)
   '(ns-alternate-modifier 'meta)
   '(ns-right-alternate-modifier 'alternate)
   '(ns-command-modifier 'super)
   '(ns-right-command-modifier 'meta)))
#+END_SRC

*** Window handling

We overrule =C-x ^= to use our window resizing method.

#+BEGIN_SRC emacs-lisp
(global-set-key [remap enlarge-window] #'resize-window)
#+END_SRC

And upgrade fullscreen experience. Use =M-F10= to toggle between maximized
and a size comprised of almost full height and a width just below
~split-width-threshold~; =M-F11= to toggle fullscreen including no window
decorations.

#+BEGIN_SRC emacs-lisp
(global-set-key [remap toggle-frame-fullscreen] #'toggle-maximize-frame)
(global-set-key [remap toggle-frame-maximized] #'switch-frame)
(global-set-key (kbd "<M-f11>") #'toggle-maximize-frame)
#+END_SRC

*** Remote controlling other window

As I got quite used to remote control the other window using =C-x 4= keys, 
I'm adding a few ones which I missed so far.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x4q" #'quit-restore-other-window)
(global-set-key "\C-x4l" #'go-back-other-window)
(global-set-key "\C-x4-" #'shrink-other-window-if-larger-than-buffer)
(global-set-key "\C-x4s" #'dedicate-window)
#+END_SRC

Note the window size changing keys, =C-x ^= to enlarge (also negative) and
=C-x -= to shrink if buffer is smaller than window are a little bit asymetric.
While the enlargement key can be used to enlarge and shrink the current
window, the shrink key works only in one direction. So here we define an
adjacent key for the other window. For rescue, there is always =C-x += to
balance windows.

We also want to jump to beginning/end in other window by =C-M-<= and =C-M->=
(cf. =C-M-v= and =C-M-V= to scroll pagewise in other window).

#+BEGIN_SRC emacs-lisp
(global-set-key [201326652] #'beginning-of-other-window)
(global-set-key [201326654] #'end-of-other-window)
#+END_SRC

How to get these codes? Call =M-x global-set-key RET C-M-< beg=.. to manually
define such a key, then call =C-x ESC ESC= and copy the resulting parametrized
command from minibuffer.
Alternatively, call =M-: (read-key-sequence "> ")=.

Now come the key bindings for convenient error navigation, as promised above.

#+BEGIN_SRC emacs-lisp
(define-prefix-command 'other-goto-map)
(global-set-key "\C-x4\M-g" 'other-goto-map)
(define-key other-goto-map "\M-n" #'next-error-other-window)
(define-key other-goto-map "\M-p" #'previous-error-other-window)
#+END_SRC

Here we bind the temporary navigation mode to some useful keys for current and
other window.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x\C-v" (lambda () (interactive)(navigate-other-window 0)))
(global-set-key "\C-x4v" #'navigate-other-window)
#+END_SRC

*** Remote controlling other frame

Push current window buffer to own frame and revert current window to previous frame.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x5p" #'push-buffer-to-frame)
#+END_SRC

** Misc

How emacs finds its tools:

#+BEGIN_SRC emacs-lisp
(setenv "PATH" (concat "/opt/local/bin:/opt/local/sbin:" (getenv "PATH")))
#+END_SRC

Load and enable different additional packages

#+BEGIN_SRC emacs-lisp
(setq org-element-use-cache nil)  ;; temporarily disable org element cache
(load-library "realgud")
(load-library "evil")
(global-undo-tree-mode)
(require 'wdired)
(load "dired-x.el") ;; also enable C-x C-j
(require 'helm-config)
(require 'ox-rst)
(global-magit-file-mode t)

(setq erc-autojoin-channels-alist '(("freenode.net" "#latex-de" "##latinitas" "#NetBSD" "##bash-de" "#git" "#vim" "#emacs" "#erc" "#oberon" "#macosx")))
#+END_SRC

** Mode-specific customizations
*** dired

Now that ~ediff~ is configured for use in ~magit~, also use it in ~dired~.

#+BEGIN_SRC emacs-lisp
(define-key dired-mode-map "="
  (lambda ()
    "ediff file at mark and file at point."
    (interactive)
    (let ((file (dired-get-filename))
          (prev (if mark-active 
                    (save-excursion (goto-char (mark t))(dired-get-filename))
                  nil)))
      (if (and file prev)
          (ediff-files prev file)))))
#+END_SRC

*** Evil mode

**** Evil defines

Here we implement some kind of .vimrc initialization.
This is also an example of defining an evil leader key and some adjacent keymaps.

#+BEGIN_SRC emacs-lisp
(defun evil-rc ()
  "evil local init/customization"
  (define-prefix-command 'leader-map)

  (define-key evil-normal-state-map " " leader-map)

  (define-key leader-map "b" #'list-buffers)
  (define-key leader-map "#" #'bs-show)
  (define-key leader-map "l" #'global-linum-mode)

  (define-prefix-command #'evil-other-window-map)
  (define-key leader-map "4" evil-other-window-map)
  (define-key evil-other-window-map "-" #'shrink-other-window-if-larger-than-buffer)
  (define-key evil-other-window-map "+" #'fit-other-window)
  (define-key evil-other-window-map "q" #'quit-restore-other-window)
  (define-key evil-other-window-map "l" #'go-back-other-window))
#+END_SRC

**** Evil Emacs config

When using evil-mode, set ~evil-exit-emacs-state~ to =C-M-z=, as I'm used to
~suspend-frame~. Additionally, always enter evil mode in emacs state (see custom). This
way, without getting in the way it is always only a key press away.

#+BEGIN_SRC emacs-lisp
(define-key evil-emacs-state-map "\C-z" nil)
(define-key evil-emacs-state-map "\C-\M-z" #'evil-exit-emacs-state)
(define-key evil-normal-state-map "\C-\M-z" #'evil-emacs-state)
#+END_SRC

Now, after Initializing evil, we may probably also activate it in all buffers.

#+BEGIN_SRC emacs-lisp
(evil-rc)
(evil-mode)
#+END_SRC

*** C++ mode customizations, in use for aeons now

#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
          (function
           (lambda ()
             (c-toggle-auto-hungry-state 1)
             (c-set-style "Stroustrup")
	     (setq c-basic-offset 2)
             (setq c-hanging-braces-alist '((brace-list-open)
                                            (brace-list-close after)
                                            (defun-open after)
                                            (class-open after)
                                            (inline-open after)
                                            (substatement-open after))))))
#+END_SRC

*** Auto-fill-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'fundamental-mode-hook
         (lambda () (auto-fill-mode 1)))
(add-hook 'text-mode-hook
         (lambda () (auto-fill-mode 1)))
(add-hook 'org-mode-hook
         (lambda () (auto-fill-mode 1)))
#+END_SRC

*** python mode

We use hippie-expand mapped to =M-/=

#+BEGIN_SRC emacs-lisp
(global-set-key [remap dabbrev-expand] #'hippie-expand)
#+END_SRC

We want to use flycheck in python.

#+BEGIN_SRC emacs-lisp
(require 'flycheck)
#+END_SRC

~elpy-mode~ defines a bunch of useful support functions for navigating and
indenting in python buffers. Notably =C-c C-d= documentation for item under
point, =M-.= jump to definition of item under cursor, =M-*= pop back to where
=M-.= was last invoked, =C-c C-o= show all python definitions of current
buffer in occur view, =C-c C-z= switch to python shell.
For this, set ~python-shell-interpreter~ to path of buildout powerscript exe and
~python-shell-interpreter-args~ to "" (see custom).
Also worth to remember the company backend completion on =C-M-i=.

#+BEGIN_SRC emacs-lisp
(elpy-enable)
#+END_SRC

To navigate using more convenient keys, we put the block navigation moves
(block in, block out, within block up and down) to =f=, =b=, =p= and =n=
combined with =C-M=. Other useful functions already on convenient keys are
=S-RET= open and indent line below, =C-S-RET= open and indent line above.
Also the python indentation functions (=C-c <= and =C-c >=) are remapped to
elpy. The =M-i= and =M-I= bindings first have to prove themselves.

#+BEGIN_SRC emacs-lisp
(define-key elpy-mode-map "\C-\M-p" #'elpy-nav-backward-block)
(define-key elpy-mode-map "\C-\M-n" #'elpy-nav-forward-block)
(define-key elpy-mode-map "\C-\M-f" #'elpy-nav-forward-indent)
(define-key elpy-mode-map "\C-\M-b" #'elpy-nav-backward-indent)
(define-key elpy-mode-map "\M-i" #'elpy-nav-indent-shift-right)
(define-key elpy-mode-map "\M-I" #'elpy-nav-indent-shift-left)
(define-key elpy-mode-map [remap python-indent-shift-right] #'elpy-nav-indent-shift-right)
(define-key elpy-mode-map [remap python-indent-shift-left] #'elpy-nav-indent-shift-left)
#+END_SRC

The visibility toggling is on completely brain damaged keys, so we put at
least the toggle at point function at =S-tab=, being as convenient as in org
mode.

#+BEGIN_SRC emacs-lisp
;; (w32-register-hot-key (kbd "<M-tab>")) ; example of hot key override, but not practical
(define-key elpy-mode-map (kbd "<S-tab>") #'elpy-folding-toggle-at-point)
#+END_SRC

Enable autopep8, but don't activate it on save. However, use =M-g M-n= and
=M-g M-p= for flycheck next and flycheck previous error, which also show pep8 errors.

#+BEGIN_SRC emacs-lisp
(require 'py-autopep8)
;;(add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
(define-key elpy-mode-map [remap previous-error] #'flycheck-previous-error)
(define-key elpy-mode-map [remap next-error] #'flycheck-next-error)
#+END_SRC

elpy makes indentation levels visible columnwise, so we also highlight the
current line of point.
As this is not only for python, currently enabled only in customize.

#+BEGIN_SRC emacs-lisp
;; (global-hl-line-mode)
#+END_SRC

The untabify-function defined here is disabled. Instead, we use custom
variable ~indent-tabs-mode~. Nevertheless, this may serve as an example, so it
stays here. custom python mode hook also activates jedi and superword mode.

#+BEGIN_SRC emacs-lisp
;; (defun python-mode-untabify ()
;;     (save-excursion
;;       (goto-char (point-min))
;;       (while (re-search-forward "[ \t]+$" nil t)
;;         (delete-region (match-beginning 0) (match-end 0)))
;;       (goto-char (point-min))
;;       (if (search-forward "\t" nil t)
;;           (untabify (1- (point)) (point-max))))
;;     nil)

;;(add-hook 'python-mode-hook
;;            '(lambda ()
;;               (make-local-variable 'write-contents-hooks)
;;               (add-hook 'write-contents-hooks 'python-mode-untabify)))
#+END_SRC

*** React programming

Combine javascript and web-mode, supporting ~jsx~ templates within. This is
probably outdated and should be re-evaluated. Is there already a real
react-mode? Otherwise, combine it with more up-to-date html-mode?

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.jsx\\'" . web-mode))
(add-hook 'web-mode-hook 'js2-minor-mode)
#+END_SRC

*** XML-mode 

**** hiding of subtrees

Here we use ~hs-mode~, enabling tag view toggling and tag level hiding. Also
~S-mouse-2~ can be used to toggle tag views.

#+BEGIN_SRC emacs-lisp
(setq sgml-quick-keys t)
(require 'hideshow)
(require 'sgml-mode)
(require 'nxml-mode)

(add-to-list 'hs-special-modes-alist
             '(nxml-mode
               "<!--\\|<[^/>]*[^/]>"
               "-->\\|</[^/>]*[^/]>"

               "<!--"
               sgml-skip-tag-forward
               nil))

(add-hook 'nxml-mode-hook 'hs-minor-mode)

(define-key nxml-mode-map (kbd "C-c C-h") 'hs-toggle-hiding)
(define-key nxml-mode-map (kbd "C-c C-l") 'hs-hide-level)
#+END_SRC

**** tagedit-mode

tbd

*** smartparens mode

In emacs lisp, we want slurp and barf support via smartparens. As the default
conflicts with my habits, we define our own mapping here.
Also use our delimiter for parens.

#+BEGIN_SRC emacs-lisp
(require 'smartparens-config)
(sp--populate-keymap
 (let ((my-sp-bindings '(("C-M-f" . sp-forward-sexp) ;; navigation
                         ("C-M-b" . sp-backward-sexp)
                         ("C-M-u" . sp-backward-up-sexp)
                         ("C-M-d" . sp-down-sexp)
                         ("C-M-p" . sp-backward-parallel-sexp)
                         ("C-M-n" . sp-forward-parallel-sexp)
                         ("C-M-k" . sp-kill-sexp)
                         ("C-M-w" . sp-copy-sexp)
                         ("M-F" . sp-forward-symbol)
                         ("M-B" . sp-backward-symbol)
                         ("C-M-SPC" . sp-mark-sexp)
                         ("C-c s" . sp-splice-sexp) ;; depth-changing commands
                         ("C-c S" . (lambda (&optional arg) (interactive "P") (my-delimit-region arg ?\()))
                         ("C-c b" . sp-splice-sexp-killing-backward)
                         ("C-c f" . sp-splice-sexp-killing-forward)
                         ("C-c k" . sp-splice-sexp-killing-around)
                         ("C-c )" . sp-forward-slurp-sexp) ;; barf/slurp
                         ("C-c }" . sp-forward-barf-sexp)
                         ("C-c (" . sp-backward-slurp-sexp)
                         ("C-c {" . sp-backward-barf-sexp)
                         ("C-c C-s" . sp-split-sexp)
                         ("C-c C-]" . sp-select-next-thing-exchange)
                         ("C-c ]" . sp-select-next-thing)
                         )))
   my-sp-bindings))
(add-hook 'emacs-lisp-mode-hook #'smartparens-mode)
#+END_SRC

*** markdown mode

#+BEGIN_SRC emacs-lisp
(autoload 'markdown-mode "markdown-mode"
  "Major mode for editing Markdown files" t)
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
(setq markdown-command "/Users/jko/Programming/node/node_modules/.bin/md2html")
#+END_SRC

** Disabled commands

#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
(put 'narrow-to-page 'disabled nil)
(put 'set-goal-column 'disabled nil)
#+END_SRC

** Todo
*** TODO macro for command composition
    - compose key 1 and key 2
    - assign function name
    - where-is-internal - find key bindings for function
    - key-binding - find function for key binding
*** finetune nth-window and other window handling
    - s f. other-window-for-scrolling and v. other-window-scroll-buffer
    - works now if no 1 prefix arg given
*** TODO complete keyboard switching
*** TODO complete mouse/trackpad handling/switching
*** TODO cleanup misc, move to mode specific sections
*** DONE env-mode: use make-composed-keymap, set-keymap-parent
    this way, each action can define an own keymap indefinitely existing and
    just adding/removing it on enter/exit. Advantage is, rebind commands
    should also be effective on these existing keymaps.
    - also: call first toggle-my-environment on mode init. So if envs are
      defined, we are always in one of the valid states.
*** DONE think about movement/search placing point on beginning of adjacent object
    done at least for searching
