map ü <C-]>	set ü to jump to tag
let mapleader=" "	define leader key
map <leader>q x	define key mapping in your name space
`<m>		jump to mark, line and column
`<M>		jump to mark, file, line, column
m<m>		define mark as this position
"<r>y<movemnt>	insert yank to register
"<R>y<movemnt>	append yank to register
"<r>p		paste contents of register/recorded macro
"<r>yy		yank line into macro definition/register
"*		clipboard register

C-i C-o		next/prev jump
C-^		switch between main and alt file
<count> C-^	switch to file #
.		repeat last change
&		repeat last substitution
* #		search for word under cursor /backwards
gv		select last visual block
gi		goto last insert pos in insert mode
gR		overwrite text; replace mode
gn		goto next search result and visually select
g;		goto last change pos
Q		ex mode
ZQ		leave without saving
ZZ		save and leave
/find/;/find2/	jump to first then to second
<ex>|<ex>	separate ex cmds by |
"[0-9]		numbered registers: last deletes
C-v		visual block: I, A, c etc operate on all 
		block lines

insert mode:
CTRL R		insert register (like CTRL O "<reg> p)
CTRL O		goto normal mode for one command

:registers	show registers
:ls		file buffers
:buffer <n>	switch to buffer
:jumps
:marks
:changes
:global		select each line matching re, execute command
:print, list	print range (# for numbered)
:delete		del range
:move		move range
:substitute	substitute matches of re by repl
:insert,append	insert lienes after pos, until .
:normal		execute vi commands in ex mode
:visual		in global, for each matching line, go to vi mode, edit until Q.
:mksession	save complete state/windows for later re-use
:cq		cancel (compile or checkin) and quit
:@<reg>		execute ex commands in register
:let @q = '<macro definition>'
:let i+=1
\=		rest of replacement is expression (i . " ")

.exrc:
set autoindent
set mouse=a
map <ScrollWheelDown> <C-e>
map <ScrollWheelUp> <C-y>

git log | vim -R -	view git log - K shows commit details
			(set filetype=git)
